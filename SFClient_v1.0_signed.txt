#Requires -Version 3.0
#This File is in Unicode format.  Do not edit in an ASCII editor.

<#
.SYNOPSIS
	Documents a Citrix StoreFront server installation (single server or server group).
.DESCRIPTION
	This script is the second part of a 2-script process to document a Citrix StoreFront server (group) installation.
	The first script, SFServer.ps1, creates an XML document of the installation, and this script
	proceses the XML file as input and documents the installation using Microsoft Word, PDF, text, 
	HTML and PowerShell.
	
	Word and PDF documents include a Cover Page, Table of Contents and Footer.
	Includes support for the following language versions of Microsoft Word:
		Catalan
		Danish
		Dutch
		English
		Finnish
		French
		German
		Norwegian
		Portuguese
		Spanish
		Swedish

	Look for the section called "GUI Customizations" to find the lines that you may wish to modify  
	for your script needs.
	
	The script parameters may be specified either on the command line or via a self-configuring GUI.
	Any parameters passed on the command line will also pre-fill the corresponding fields on the GUI
	(if a GUI is requested). 
	
	This script is based on the extensive work on documentation scripts done by Carl Webster et al.
	The latest set of scripts may be found at: carlwebster.com.
	
.PARAMETER GUI
	Get all parameter inputs from a graphical user interface. Any parameters passed to the script will 
	be used as defaults for the corresponding fields on the form.
	This parameter is set to True by default. Use -GUI:$False on the command line to turn off.
	Turning off the GUI would be used when running the script via an automated process.
	
.PARAMETER CompanyName
	Alias: CN
	Company Name to use for the Cover Page.  
	Default value is contained in HKCU:\Software\Microsoft\Office\Common\UserInfo\CompanyName or
	HKCU:\Software\Microsoft\Office\Common\UserInfo\Company, whichever is populated on the 
	computer running the script.
	If neither registry key exists and this parameter is not specified, the report will
	not contain a Company Name on the cover page.
	
.PARAMETER CoverPage
	Alias: CP
	What Microsoft Word cover page to use.
	Only Word 2010 and 2013 are supported.
	Valid inputs for cover pages in Word en-US are:
		Alphabet (Word 2010. Works)
		Annual (Word 2010. Doesn't work well for this report)
		Austere (Word 2010. Works)
		Austin (Word 2010/2013. Doesn't work in 2013, mostly works in 2010 but Subtitle/Subject & Author fields need adjusting)
		Banded (Word 2013. Works)
		Conservative (Word 2010. Works)
		Contrast (Word 2010. Works)
		Cubicles (Word 2010. Works)
		Exposure (Word 2010. Works if you like looking sideways)
		Facet (Word 2013. Works)
		Filigree (Word 2013. Works)
		Grid (Word 2010/2013.Works in 2010)
		Integral (Word 2013. Works)
		Ion (Dark) (Word 2013. Top date doesn't fit, box needs to be manually resized or font changed to 8 point)
		Ion (Light) (Word 2013. Top date doesn't fit, box needs to be manually resized or font changed to 8 point)
		Mod (Word 2010. Works)
		Motion (Word 2010/2013. Works if top date is manually changed to 36 point)
		Newsprint (Word 2010. Works but date is not populated)
		Perspective (Word 2010. Works)
		Pinstripes (Word 2010. Works)
		Puzzle (Word 2010. Top date doesn't fit, box needs to be manually resized or font changed to 14 point)
		Retrospect (Word 2013. Works)
		Semaphore (Word 2013. Works)
		Sideline (Word 2010/2013. Doesn't work in 2013, works in 2010)
		Slice (Dark) (Word 2013. Doesn't work)
		Slice (Light) (Word 2013. Doesn't work)
		Stacks (Word 2010. Works)
		Tiles (Word 2010. Date doesn't fit unless changed to 26 point)
		Transcend (Word 2010. Works)
		ViewMaster (Word 2013. Works)
		Whisp (Word 2013. Works)
	The default value for culture en- is Sideline.
	When using the GUI, only cover pages for the version of MS Word installed and the OS culture in use are loaded.
	
.PARAMETER UserName
	Alias: UN
	User name to use for the cover page and footer.
	The default value used is $env:username

.PARAMETER InputFile
	Alias: IN
	Full path to the input .XML file generated by the first script (SFServer.ps1).
	The current directory is used if the file name does not contain a path.

.PARAMETER OutputFile
	Alias: OUT
	The name of the output file to be generated - should not contain a path (see OutputDir) or extension.

.PARAMETER OutputDir
	Alias: OUTDIR
	The directory into which to place the generated file.
	The current directory is used if not specified.
	
.PARAMETER PDF
	Save the output as a PDF file instead of DOCX file.
	This parameter is off by default.
	The PDF file is roughly 5X to 10X larger than the DOCX file.
	
.PARAMETER Text
	Creates a text file with a .txt extension.
	This parameter is off by default.
	
.PARAMETER MSWord
	Save the output document as a DOCX (Microsoft Word) file.
	This parameter is set to True if no other output format is selected.
	
.PARAMETER HTML
	Creates an HTML file with an .html extension.
	This parameter is off by default.
	This parameter is reserved for a future use and is not available at this time.
	
.PARAMETER AddDateTime
	Adds a date time stamp to the end of the file name.
	Time stamp is in the format of yyyy-MM-dd_HHmm.
	For example, June 1, 2014 at 6PM is 2014-06-01_1800.
	The output filename will be ReportName_2014-06-01_1800.docx (or .pdf).
	This parameter is off by default.

.EXAMPLE
	PS C:\PS> .\SF-Client.ps1
	
	Will use all default values. So, for example, the following:
	HKEY_CURRENT_USER\Software\Microsoft\Office\Common\UserInfo\CompanyName="IPM" or
	HKEY_CURRENT_USER\Software\Microsoft\Office\Common\UserInfo\Company="IPM"
	$env:username = Sam.Jacobs

	Will use:
	IPM for the Company Name.
	Sideline for the Cover Page format.
	Sam.Jacobs for the User Name.
	
.EXAMPLE
	PS C:\PS> .\SF-Client.ps1 -PDF
	
	Will use all default values and save the document as a PDF file.

.EXAMPLE
	PS C:\PS> .\SF-Client.ps1 -GUI:$False -InputFile "C:\Client\IPM\StoreFront.xml" -OutputFile "StoreFront-IPM" -OutputDir "C:\Output"

	Will use:
	"C:\Client\IPM\StoreFront.xml" as the input XML file.
	"StoreFront-IPM" as the output file name (the extension would depend on the output type selected).
	"C:\Output" as the output directory.
	All other values would use the defaults.

.EXAMPLE
	PS C:\PS> .\SF-Client.ps1 -CompanyName "TechDev Services" -CoverPage "Facet" -UserName "Sam Jacobs"

	Will use:
		TechDev Services for the Company Name.
		Facet for the Cover Page format.
		Sam Jacobs for the User Name.
		
.EXAMPLE
	PS C:\PS> .\SF-Client.ps1 -CN "TechDev Services" -CP "Facet" -UN "Sam Jacobs"

	Will output the same as the previous example (using alias names).

.INPUTS
	None.  You cannot pipe objects to this script.
	
.OUTPUTS
	No objects are output from this script.  
	This script creates a Word, PDF, Text or HTML document.
	
.NOTES
	NAME:     SFClient.ps1
	VERSION:  1.00
	AUTHOR:   Sam Jacobs, with routines by Carl Webster, Michael B. Smith, Iain Brighton, Jeff Wouters, Barry Schiffer
	LASTEDIT: July 20, 2015
#>

# Thanks to:
#   Carl Webster, Michael B. Smith, Iain Brighton, Jeff Wouters, and Barry Schiffer for their routines used in this script.

#~~< Parameters >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[CmdletBinding(SupportsShouldProcess = $False, ConfirmImpact = "None", DefaultParameterSetName = "Word") ]

Param(
	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[Switch]$MSWord=$False,

	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Switch]$PDF=$False,

	[parameter(ParameterSetName="Text",Mandatory=$False)] 
	[Switch]$Text=$False,

	[parameter(ParameterSetName="HTML",Mandatory=$False)] 
	[Switch]$HTML=$False,

	[parameter(Mandatory=$False)] 
	[Switch]$AddDateTime=$False,
	
	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("CN")]
	[ValidateNotNullOrEmpty()]
	[string]$CompanyName="",
    
	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("CP")]
	[ValidateNotNullOrEmpty()]
	[string]$CoverPage="Sideline", 

	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("UN")]
	[ValidateNotNullOrEmpty()]
	[string]$UserName=$env:username,

	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("IN")]
	[ValidateNotNullOrEmpty()]
	[string]$InputFile="",
    
	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("OUT")]
	[ValidateNotNullOrEmpty()]
	[string]$OutputFile="",

	[parameter(ParameterSetName="Word",Mandatory=$False)] 
	[parameter(ParameterSetName="PDF",Mandatory=$False)] 
	[Alias("OUTDIR")]
	[ValidateNotNullOrEmpty()]
	[string]$OutputDir="",

	[parameter(Mandatory=$False)] 
	[Switch]$GUI=$True

	)

Set-StrictMode -Version 2

##$PSDefaultParameterValues = @{"*:Verbose"=$True}
$SaveEAPreference = $ErrorActionPreference
$ErrorActionPreference = 'SilentlyContinue'

Write-Verbose "$(Get-Date): Processing parameters from command line ..."
If($MSWord -eq $True) { Write-Verbose "$(Get-Date): MSWord: True" }
If($PDF -eq $True) { Write-Verbose "$(Get-Date): PDF: True" }
If($Text -eq $True) { Write-Verbose "$(Get-Date): Text: True" }
If($HTML -eq $True) { Write-Verbose "$(Get-Date): HTML: True" }
If($AddDateTime -eq $True) { Write-Verbose "$(Get-Date): AddDateTime: True" }
If($GUI -eq $True) { Write-Verbose "$(Get-Date): GUI: True" }
If($CompanyName -ne "") { Write-Verbose "$(Get-Date): CompanyName: $($CompanyName)" }
If($CoverPage -ne "") { Write-Verbose "$(Get-Date): CoverPage: $($CoverPage)" }
If($UserName -ne "") { Write-Verbose "$(Get-Date): UserName: $($UserName)" }
If($InputFile -ne "") { Write-Verbose "$(Get-Date): InputFile: $($InputFile)" }
If($OutputFile -ne "") { Write-Verbose "$(Get-Date): OutputFile: $($OutputFile)" }
If($OutputDir -ne "") { Write-Verbose "$(Get-Date): OutputDir: $($OutputDir)" }

If($inputFile -eq "" -and $GUI -eq $False)
{
	Write-Verbose "$(Get-Date): Missing input file ... try using -GUI switch."
	Exit
}
If (!(Test-Path ($inputFile))) 
{
	Write-Verbose "$(Get-Date): Input file does not exist! ... try using -GUI switch."
	Exit
}
If($PDF -eq $Null)
{
	$PDF = $False
}
If($Text -eq $Null)
{
	$Text = $False
}
If($MSWord -eq $Null)
{
	$MSWord = $False
}
If($HTML -eq $Null)
{
	$HTML = $False
}
If($AddDateTime -eq $Null)
{
	$AddDateTime = $False
}

If(!(Test-Path Variable:PDF))
{
	$PDF = $False
}
If(!(Test-Path Variable:Text))
{
	$Text = $False
}
If(!(Test-Path Variable:MSWord))
{
	$MSWord = $False
}
If(!(Test-Path Variable:HTML))
{
	$HTML = $False
}
If(!(Test-Path Variable:AddDateTime))
{
	$AddDateTime = $False
}

If($MSWord -eq $Null)
{
	If($Text -or $HTML -or $PDF)
	{
		$MSWord = $False
	}
	Else
	{
		$MSWord = $True
	}
}

If($MSWord -eq $False -and $PDF -eq $False -and $Text -eq $False -and $HTML -eq $False)
{
	Write-Verbose "$(Get-Date): Output format not selected ... defaulting to MS Word."
	$MSWord = $True
}

If($OutputDir -eq "")
{	
	Write-Verbose "$(Get-Date): Output directory defaulting to current directory: $pwd"
	$OutputDir = $pwd
}

#region Documentation GUI

#~~< GUI Customizations go here >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# title used for the form and any pop-up message boxes
$GUI_title  = "StoreFront Documentation Script - Part 2 of 2"

# default output file name (no extension)
$defaultOutputFile = "StoreFront"

# default cover page
$defaultCoverPage = "Sideline"

# input file file filter 
$fileFilter = "StoreFront XML (*.xml)|*.xml|All files (*.*)| *.*"

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#   GUI component for documentation scripts 
#   Author:      Sam Jacobs, IPM
#   Created:     July, 2014
#   Version:     1.0
#   Last Update: August 8, 2014 
#
#   Modification History
#	2014-08-10	added $Hardware and $Software to self-configuration
#	2014-08-08	allow GUI to self-configure, 
#				based on existence of script variables $ComputerName and $InputFile
#	2014-07-24	initial version
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[void][System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms")
[void][System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")

$continueProcessing = $True

#~~< Message Box buttons >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[int]$MB_OK					= 0
[int]$MB_OK_CANCEL			= 1
[int]$MB_ABORT_RETRY_IGNORE = 2
[int]$MB_YES_NO_CANCEL		= 3
[int]$MB_YES_NO				= 4
[int]$MB_RETRY_CANCEL		= 5

#~~< Message Box icons >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[int]$MB_ICON_CRITICAL		= 16
[int]$MB_ICON_QUESTION		= 32
[int]$MB_ICON_WARNING		= 48
[int]$MB_ICON_INFORMATIONAL	= 64

$extensions = @(".docx", ".pdf", ".txt", ".html")

#~~< GUI Functions >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Function getDirectory($prompt, $startDir) {

	Add-Type -AssemblyName System.Windows.Forms
	$folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
	$folderBrowser.Description = $prompt
	$folderBrowser.SelectedPath = $startDir
	[void]$folderBrowser.ShowDialog()
	Return $folderBrowser.SelectedPath
}

Function populateDirectory () {
	$selectedDir = getDirectory "Please select output directory:" $txtOutputDir.Text
	if ($selectedDir -ne "") {
		$txtOutputDir.Text = $selectedDir
	}
}

Function Get-FileName($initialDirectory)
{   
 [System.Reflection.Assembly]::LoadWithPartialName("System.Windows.Forms") |  Out-Null
 $dlgOpenFile = New-Object System.Windows.Forms.OpenFileDialog
 $dlgOpenFile.initialDirectory = $initialDirectory
 $dlgOpenFile.filter = $fileFilter
 $dlgOpenFile.ShowDialog() | Out-Null
 $dlgOpenFile.filename
} 

Function selectFile () {
	# if the input file specified is valid, get the directory for the Get-FileName call
	$inputDirectory = Split-Path $txtInputFile.Text
    If ($inputDirectory -eq "") {
        $inputDirectory = $pwd
    } ElseIf (!(Test-Path $inputDirectory)) {
		$inputDirectory = $pwd
	}
	$selectedFile = Get-FileName $inputDirectory
	if (($selectedFile -ne $Null) -and ($selectedFile -ne "")) {
		$txtInputFile.Text = $selectedFile
	}
}


Function cboOutputFormat_SelectedIndexChanged {
	# if the output format changes, then change the extension
	$lblExt.Text = $extensions[$cboOutputFormat.SelectedIndex]
	If(($lblExt.Text -eq ".docx") -or ($lblExt.Text -eq ".pdf"))
	{
		$lblCoverPage.Visible = $True
		$cboCoverPage.Visible = $True
	}	Else 
	{
		$lblCoverPage.Visible = $False
		$cboCoverPage.Visible = $False
	}
}

Function Continue_Script() {
	# save fields needed from form before closing
	$Script:CompanyName = $txtCompanyName.Text
	$Script:UserName = $txtUserName.Text
	If($cboCoverPage.SelectedIndex -gt -1) {
		$Script:CoverPage = $cboCoverPage.Text
	}
	switch ($extensions[$cboOutputFormat.SelectedIndex]) {
		".pdf"  {$Script:PDF = $True;$Script:HTML = $False;$Script:TEXT = $False;$Script:MSWord = $False;}
		".html" {$Script:HTML = $True;$Script:PDF = $False;$Script:TEXT = $False;$Script:MSWord = $False;}
		".txt"  {$Script:TEXT = $True;$Script:PDF = $False;$Script:HTML = $False;$Script:MSWord = $False;}
		default {$Script:MSWord = $True;$Script:PDF = $False;$Script:HTML = $False;$Script:TEXT = $False;}
	}
	# are we supposed to be accepting an input file?
	If (Test-Path variable:InputFile) {
		$Script:InputFile  = $txtInputFile.Text
		# make sure the file actually exists!
		If ($Script:InputFile.substring(0,1) -eq " ") {
			[System.Windows.Forms.MessageBox]::Show("Please select an input file!" , 
				$GUI_title, $MB_OK, $MB_ICON_CRITICAL)
			Return		}
		If (!(Test-Path ($Script:InputFile))) {
			[System.Windows.Forms.MessageBox]::Show("Input file does not exist!" , 
				$GUI_title, $MB_OK, $MB_ICON_CRITICAL)
			Return
		}
	}
	$Script:CompanyName = $txtCompanyName.Text
	$Script:UserName = $txtUserName.Text
	$Script:OutputFile = $txtOutputFile.Text
	$Script:OutputDir  = $txtOutputDir.Text
	# make sure the output directory exists
	If (!(Test-Path ($Script:OutputDir))) {
		[System.Windows.Forms.MessageBox]::Show("Output directory does not exist!" , 
			$GUI_title, $MB_OK, $MB_ICON_CRITICAL)
		Return
	}
	$Script:AddDateTime = ($chkAddDate.Checked -eq $True)
	$Script:Hardware = ($chkHardware.Checked -eq $True)
	$Script:Software = ($chkSoftware.Checked -eq $True)
	
	$Script:continueProcessing = $True
	$formDoc.Close()
}

Function Abort_Script() {
	$Script:continueProcessing = $False
	$formDoc.Close()
}

#~~< create the GUI >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Function ProcessGUI {
		
		$label16 = New-Object System.Windows.Forms.Label
		$grpTarget = New-Object System.Windows.Forms.GroupBox
		$txtComputerName = New-Object System.Windows.Forms.TextBox
		$lblExt = New-Object System.Windows.Forms.Label
		$btnSelectOutputDir = New-Object System.Windows.Forms.Button
		$grpOutput = New-Object System.Windows.Forms.GroupBox
		$txtOutputDir = New-Object System.Windows.Forms.TextBox
		$txtOutputFile = New-Object System.Windows.Forms.TextBox
		$cboCoverPage = New-Object System.Windows.Forms.ComboBox
		$cboOutputFormat = New-Object System.Windows.Forms.ComboBox
		$label9 = New-Object System.Windows.Forms.Label
		$lblCoverPage = New-Object System.Windows.Forms.Label
		$label4 = New-Object System.Windows.Forms.Label
		$label3 = New-Object System.Windows.Forms.Label
		$label7 = New-Object System.Windows.Forms.Label
		$btnExit = New-Object System.Windows.Forms.Button
		$btnGenerate = New-Object System.Windows.Forms.Button
		$grpOptional = New-Object System.Windows.Forms.GroupBox
		$chkHardware = New-Object System.Windows.Forms.CheckBox
		$chkAddDate = New-Object System.Windows.Forms.CheckBox
		$chkSoftware = New-Object System.Windows.Forms.CheckBox
		$label8 = New-Object System.Windows.Forms.Label
		$grpUserInfo = New-Object System.Windows.Forms.GroupBox
		$txtUserName = New-Object System.Windows.Forms.TextBox
		$txtCompanyName = New-Object System.Windows.Forms.TextBox
		$lblculture = New-Object System.Windows.Forms.Label
		$grpInput = New-Object System.Windows.Forms.GroupBox
		$btnSelectInputFile = New-Object System.Windows.Forms.Button
		$txtInputFile = New-Object System.Windows.Forms.TextBox
		$label1 = New-Object System.Windows.Forms.Label
		## 
		## label16
		## 
		$label16.AutoSize = $True
		$label16.Location = New-Object System.Drawing.Point(14, 29)
		$label16.Name = "label16"
		$label16.Size = New-Object System.Drawing.Size(83, 13)
		$label16.TabIndex = 0
		$label16.Text = "Computer Name"
		## 
		## grpTarget
		## 
		$grpTarget.Controls.Add($txtComputerName)
		$grpTarget.Controls.Add($label16)
		$grpTarget.Location = New-Object System.Drawing.Point(59, 29)
		$grpTarget.Name = "grpTarget"
		$grpTarget.Size = New-Object System.Drawing.Size(405, 59)
		$grpTarget.TabIndex = 22
		$grpTarget.TabStop = $False
		$grpTarget.Text = " Target "
		$grpTarget.Visible = $False		#default to hidden
		## 
		## txtComputerName
		## 
		$txtComputerName.Location = New-Object System.Drawing.Point(104, 25)
		$txtComputerName.Name = "txtComputerName"
		$txtComputerName.Size = New-Object System.Drawing.Size(265, 20)
		$txtComputerName.TabIndex = 4
		$txtComputerName.Text = "Localhost"
		## 
		## lblExt
		## 
		$lblExt.AutoSize = $True
		$lblExt.Font = New-Object System.Drawing.Font("Microsoft Sans Serif", 9, [System.Drawing.FontStyle]::Bold)
		$lblExt.Location = New-Object System.Drawing.Point(324, 90)
		$lblExt.Name = "lblExt"
		$lblExt.Size = New-Object System.Drawing.Size(41, 15)
		$lblExt.TabIndex = 11
		$lblExt.Text = ".docx"
		$lblExt.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter
		## 
		## btnSelectOutputDir
		## 
		$btnSelectOutputDir.Location = New-Object System.Drawing.Point(327, 56)
		$btnSelectOutputDir.Name = "btnSelectOutputDir"
		$btnSelectOutputDir.Size = New-Object System.Drawing.Size(37, 20)
		$btnSelectOutputDir.TabIndex = 10
		$btnSelectOutputDir.Text = "..."
		$btnSelectOutputDir.TextAlign = [System.Drawing.ContentAlignment]::TopCenter
		$btnSelectOutputDir.UseVisualStyleBackColor = $True
		## 
		## grpOutput
		## 
		$grpOutput.Controls.Add($lblculture)
		$grpOutput.Controls.Add($lblExt)
		$grpOutput.Controls.Add($btnSelectOutputDir)
		$grpOutput.Controls.Add($txtOutputDir)
		$grpOutput.Controls.Add($txtOutputFile)
		$grpOutput.Controls.Add($cboCoverPage)
		$grpOutput.Controls.Add($cboOutputFormat)
		$grpOutput.Controls.Add($label9)
		$grpOutput.Controls.Add($lblCoverPage)
		$grpOutput.Controls.Add($label4)
		$grpOutput.Controls.Add($label3)
		$grpOutput.Location = New-Object System.Drawing.Point(59, 107)
		$grpOutput.Name = "grpOutput"
		$grpOutput.Size = New-Object System.Drawing.Size(405, 156)
		$grpOutput.TabIndex = 17
		$grpOutput.TabStop = $False
		$grpOutput.Text = " Output "
		## 
		## txtOutputDir
		## 
		$txtOutputDir.Location = New-Object System.Drawing.Point(103, 56)
		$txtOutputDir.Name = "txtOutputDir"
		$txtOutputDir.Size = New-Object System.Drawing.Size(215, 20)
		$txtOutputDir.TabIndex = 9
		## 
		## txtOutputFile
		## 
		$txtOutputFile.Location = New-Object System.Drawing.Point(103, 88)
		$txtOutputFile.Name = "txtOutputFile"
		$txtOutputFile.Size = New-Object System.Drawing.Size(215, 20)
		$txtOutputFile.TabIndex = 8
		$txtOutputFile.Text = $defaultOutputFile
		## 
		## cboCoverPage
		## 
		$cboCoverPage.FormattingEnabled = $True

		$cboCoverPage.Location = New-Object System.Drawing.Point(103, 121)
		$cboCoverPage.Name = "cboCoverPage"
		$cboCoverPage.Size = New-Object System.Drawing.Size(215, 21)
		$cboCoverPage.TabIndex = 6
		## 
		## cboOutputFormat
		## 
		$cboOutputFormat.FormattingEnabled = $True

		$cboOutputFormat.Location = New-Object System.Drawing.Point(103, 25)
		$cboOutputFormat.Name = "cboOutputFormat"
		$cboOutputFormat.Size = New-Object System.Drawing.Size(265, 21)
		$cboOutputFormat.TabIndex = 5
		## 
		## label9
		## 
		$label9.AutoSize = $True
		$label9.Location = New-Object System.Drawing.Point(14, 26)
		$label9.Name = "label9"
		$label9.Size = New-Object System.Drawing.Size(39, 13)
		$label9.TabIndex = 4
		$label9.Text = "Format"
		## 
		## lblCoverPage
		## 
		$lblCoverPage.AutoSize = $True
		$lblCoverPage.Location = New-Object System.Drawing.Point(14, 124)
		$lblCoverPage.Name = "lblCoverPage"
		$lblCoverPage.Size = New-Object System.Drawing.Size(63, 13)
		$lblCoverPage.TabIndex = 3
		$lblCoverPage.Text = "Cover Page"
		## 
		## label4
		## 
		$label4.AutoSize = $True
		$label4.Location = New-Object System.Drawing.Point(14, 56)
		$label4.Name = "label4"
		$label4.Size = New-Object System.Drawing.Size(49, 13)
		$label4.TabIndex = 1
		$label4.Text = "Directory"
		## 
		## label3
		## 
		$label3.AutoSize = $True
		$label3.Location = New-Object System.Drawing.Point(14, 89)
		$label3.Name = "label3"
		$label3.Size = New-Object System.Drawing.Size(49, 13)
		$label3.TabIndex = 0
		$label3.Text = "Filename"
		## 
		## label7
		## 
		$label7.AutoSize = $True
		$label7.Location = New-Object System.Drawing.Point(13, 27)
		$label7.Name = "label7"
		$label7.Size = New-Object System.Drawing.Size(82, 13)
		$label7.TabIndex = 1
		$label7.Text = "Company Name"
		## 
		## btnExit
		## 
		$btnExit.Location = New-Object System.Drawing.Point(291, 508)
		$btnExit.Name = "btnExit"
		$btnExit.Size = New-Object System.Drawing.Size(147, 30)
		$btnExit.TabIndex = 21
		$btnExit.Text = "Exit"
		$btnExit.UseVisualStyleBackColor = $True
		## 
		## btnGenerate
		## 
		$btnGenerate.Location = New-Object System.Drawing.Point(80, 508)
		$btnGenerate.Name = "btnGenerate"
		$btnGenerate.Size = New-Object System.Drawing.Size(147, 30)
		$btnGenerate.TabIndex = 20
		$btnGenerate.Text = "Generate"
		$btnGenerate.UseVisualStyleBackColor = $True
		## 
		## grpOptional
		## 
		$grpOptional.Controls.Add($chkSoftware)
		$grpOptional.Controls.Add($chkHardware)
		$grpOptional.Controls.Add($chkAddDate)
		$grpOptional.Location = New-Object System.Drawing.Point(59, 387)
		$grpOptional.Name = "grpOptional"
		$grpOptional.Size = New-Object System.Drawing.Size(405, 104)
		$grpOptional.TabIndex = 19
		$grpOptional.TabStop = $False
		$grpOptional.Text = " Optional "
		## 
		## chkHardware
		## 
		$chkHardware.AutoSize = $True
		$chkHardware.Location = New-Object System.Drawing.Point(17, 49)
		$chkHardware.Name = "chkHardware"
		$chkHardware.Size = New-Object System.Drawing.Size(217, 17)
		$chkHardware.TabIndex = 4
		$chkHardware.Text = "Use WMI to gather hardware information"
		$chkHardware.UseVisualStyleBackColor = $True
		## 
		## chkAddDate
		## 
		$chkAddDate.AutoSize = $True
		$chkAddDate.Location = New-Object System.Drawing.Point(17, 26)
		$chkAddDate.Name = "chkAddDate"
		$chkAddDate.Size = New-Object System.Drawing.Size(184, 17)
		$chkAddDate.TabIndex = 3
		$chkAddDate.Text = "Add date/time stamp to file name "
		$chkAddDate.UseVisualStyleBackColor = $True
		## 
		## label8
		## 
		$label8.AutoSize = $True
		$label8.Location = New-Object System.Drawing.Point(13, 55)
		$label8.Name = "label8"
		$label8.Size = New-Object System.Drawing.Size(60, 13)
		$label8.TabIndex = 2
		$label8.Text = "User Name"
		## 
		## grpUserInfo
		## 
		$grpUserInfo.Controls.Add($txtUserName)
		$grpUserInfo.Controls.Add($txtCompanyName)
		$grpUserInfo.Controls.Add($label8)
		$grpUserInfo.Controls.Add($label7)
		$grpUserInfo.Location = New-Object System.Drawing.Point(59, 283)
		$grpUserInfo.Name = "grpUserInfo"
		$grpUserInfo.Size = New-Object System.Drawing.Size(405, 84)
		$grpUserInfo.TabIndex = 18
		$grpUserInfo.TabStop = $False
		$grpUserInfo.Text = " User Info "
		## 
		## txtUserName
		## 
		$txtUserName.Location = New-Object System.Drawing.Point(102, 50)
		$txtUserName.Name = "txtUserName"
		$txtUserName.Size = New-Object System.Drawing.Size(265, 20)
		$txtUserName.TabIndex = 4
		## 
		## txtCompanyName
		## 
		$txtCompanyName.Location = New-Object System.Drawing.Point(102, 24)
		$txtCompanyName.Name = "txtCompanyName"
		$txtCompanyName.Size = New-Object System.Drawing.Size(265, 20)
		$txtCompanyName.TabIndex = 3
		## 
		## lblculture
		## 
		$lblculture.AutoSize = $True
		$lblculture.Font = New-Object System.Drawing.Font("Microsoft Sans Serif", 9, [System.Drawing.FontStyle]::Bold)
		$lblculture.Location = New-Object System.Drawing.Point(333, 123)
		$lblculture.Name = "lblculture"
		$lblculture.Size = New-Object System.Drawing.Size(28, 15)
		$lblculture.TabIndex = 17
		$lblculture.Text = ""
		$lblculture.TextAlign = [System.Drawing.ContentAlignment]::MiddleCenter
		## 
		## grpInput
		## 
		$grpInput.Controls.Add($btnSelectInputFile)
		$grpInput.Controls.Add($txtInputFile)
		$grpInput.Controls.Add($label1)
		$grpInput.Location = New-Object System.Drawing.Point(59, 29)
		$grpInput.Name = "grpInput"
		$grpInput.Size = New-Object System.Drawing.Size(405, 59)
		$grpInput.TabIndex = 23
		$grpInput.TabStop = $False
		$grpInput.Text = "Input"
		$grpInput.Visible = $False		# default to hidden
		## 
		## btnSelectInputFile
		## 
		$btnSelectInputFile.Location = New-Object System.Drawing.Point(331, 24)
		$btnSelectInputFile.Name = "btnSelectInputFile"
		$btnSelectInputFile.Size = New-Object System.Drawing.Size(37, 20)
		$btnSelectInputFile.TabIndex = 10
		$btnSelectInputFile.Text = "..."
		$btnSelectInputFile.TextAlign = [System.Drawing.ContentAlignment]::TopCenter
		$btnSelectInputFile.UseVisualStyleBackColor = $True
		## 
		## txtInputFile
		## 
		$txtInputFile.Location = New-Object System.Drawing.Point(69, 24)
		$txtInputFile.Name = "txtInputFile"
		$txtInputFile.Size = New-Object System.Drawing.Size(256, 20)
		$txtInputFile.TabIndex = 8
		$txtInputFile.Text = "                === Select input file ==> "
		## 
		## label1
		## 
		$label1.AutoSize = $True
		$label1.Location = New-Object System.Drawing.Point(14, 29)
		$label1.Name = "label1"
		$label1.Size = New-Object System.Drawing.Size(49, 13)
		$label1.TabIndex = 0
		$label1.Text = "Filename"
		## 
		## chkSoftware
		## 
		$chkSoftware.AutoSize = $True
		$chkSoftware.Location = New-Object System.Drawing.Point(17, 75)
		$chkSoftware.Name = "chkSoftware"
		$chkSoftware.Size = New-Object System.Drawing.Size(155, 17)
		$chkSoftware.TabIndex = 5
		$chkSoftware.Text = "Gather software information"
		$chkSoftware.UseVisualStyleBackColor = $True		
		## 
		## formDoc
		## 
		$formDoc = New-Object System.Windows.Forms.Form
		
		$formDoc.ClientSize = New-Object System.Drawing.Size(524, 559)
		$formDoc.Controls.Add($grpInput)
		$formDoc.Controls.Add($grpTarget)
		$formDoc.Controls.Add($grpOutput)
		$formDoc.Controls.Add($btnExit)
		$formDoc.Controls.Add($btnGenerate)
		$formDoc.Controls.Add($grpOptional)
		$formDoc.Controls.Add($grpUserInfo)
		$formDoc.Name = "formDoc"
		$formDoc.StartPosition = [System.Windows.Forms.FormStartPosition]::CenterScreen
		$formDoc.Text = $GUI_title
		
#region formIcon

# form icon - convert to base64
[string] $iconBase64=@"
AAABAAEAICAAAAEAIACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAgBAAAMQOAADEDgAAAAAAAAAA
AAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8ASEhImk9PT7lKSko9////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wBISEjhVVVV/0lJSVn///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AEdHR9RQUFD/SEhIVP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8AR0dH1FBQUP9ISEhU////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wBHR0fUUFBQ/0dHR1X///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wBQUFA7TU1NRExMTBP///8A////AEdHR9RQUFD/SUlJRE5O
ThlPT092UlJSkE5OTmpLS0sQ////AP///wD///8A////AEZGRjVUVFREXl5eGv///wD///8AQkJCFlFR
UURFRUUr////AP///wB+fn4HTk5OQ0ZGRkQ9PT0H////AFJSUudSUlL/R0dHTf///wD///8AR0dH1E1N
Tf9HR0eZSEhI81ZWVv9UVFT/UlJS/0pKStpEREQk////AP///wD///8ASEhI01hYWP9fX19n////AP//
/wBHR0dYVlZW/0dHR6v///8A////AH9/fx1SUlL/TExM/0ZGRhz///8AUVFR3U5OTv9ISEhJ////AP//
/wBHR0fUSkpK/05OTv9HR0fOTk5Ofk5OTodJSUnpUVFR/0hISNleXl4H////AP///wBHR0fKVFRU/19f
X2L///8A////AEhISFRSUlL/R0dHpP///wD///8Ae3t7HE5OTvtISEj/SEhIG////wBRUVHcTk5O/0hI
SEn///8A////AEdHR9RPT0//TExMzWVlZQT///8A////AFBQUChKSkrrUFBQ/0pKSmL///8A////AEdH
R8lUVFT/X19fYv///wD///8ASEhIVFJSUv9HR0ej////AP///wB7e3scT09P+khISP9ISEgb////AFFR
UdxOTk7/SEhISf///wD///8AR0dH1FBQUP9PT09W////AP///wD///8A////AEpKSo5SUlL/TU1NsP//
/wD///8AR0dHyVRUVP9fX19i////AP///wBISEhUUlJS/0dHR6P///8A////AHt7exxPT0/6SEhI/0hI
SBv///8AUVFR3E5OTv9ISEhJ////AP///wBHR0fYS0tL/09PTxz///8A////AP///wD///8AR0dHX1JS
Uv9JSUnJ////AP///wBHR0fJVFRU/1xcXGL///8A////AEhISFNSUlL/SEhIof///wD///8Ae3t7HE9P
T/pISEj/SEhIG////wBRUVHcTk5O/0hISEn///8A////AEdHR9ZOTk7/T09POf///wD///8A////AP//
/wBLS0t1UlJS/01NTb7///8A////AEdHR8lSUlL/Tk5OXf///wD///8ASEhIU1BQUP9OTk7G////AP//
/wBtbW0bTU1N+khISP9ISEgb////AFFRUdxOTk7/SEhISf///wD///8AR0dH1FBQUP9PT0+j////AP//
/wD///8A////AEpKSs9SUlL/TU1Ng////wD///8AR0dHyVFRUf9NTU12////AP///wBPT0+DUFBQ/0lJ
SeD///8A////AEdHRxRJSUn6SkpK/09PTxz///8AUVFR3E5OTv9ISEhJ////AP///wBHR0fUS0tL/0xM
TP9JSUl8VFRULFRUVDVLS0uuT09P/0lJSftPT08f////AP///wBHR0fJTk5O/0lJSeNQUFA7VFRUNUlJ
SeBLS0v/T09P/05OToVUVFQsSUlJh05OTv9JSUnoVFRUBf///wBSUlLtVFRU/0lJSU////8A////AEhI
SOVRUVH/S0tL8lFRUf9PT0//TU1N/1FRUf9MTEz/R0dHX////wD///8A////AEdHR9lSUlL/UFBQ/1BQ
UP9OTk7/T09P/0lJSexMTEzRU1NT/01NTf9NTU3/UlJS/0lJSZH///8A////AFFRUYVNTU2ZSUlJLP//
/wD///8AR0dHgE1NTZlNTU03T09Pb0xMTM9NTU3lTU1NvUtLS03///8A////AP///wD///8AR0dHeVFR
UZlfX19cS0tLqU1NTd9LS0u8U1NTPHV1dQxNTU2XTU1N4E1NTdtOTk6eVFRUC////wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AKKiogr///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8AtbW1Bv///wD///8A////AP///wCfn58Hy8vLBP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AABs1l0AduyGAG3aG////wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wAXc9ggAXTm/wCA//8Abdik////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////ABN53RYBb9z/AID+/wBt15T///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AABq1UkAcuR8AGXMCf///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP//
/wD///8A////AP///wD///8A///////////////////////////8f////H////x////8f////H///4wD
xjCMAcYwjADGMIwwxjCMeMYwjHjGMIx4xjCMeMYwjADAAIwBwAGMA8AB/+/95/////+P////D////w//
//+P//////////////////////////////8=
"@
		$iconStream=[System.IO.MemoryStream][System.Convert]::FromBase64String($iconBase64)
		$iconBmp=[System.Drawing.Bitmap][System.Drawing.Image]::FromStream($iconStream)
		$iconHandle=$iconBmp.GetHicon()
		$icon=[System.Drawing.Icon]::FromHandle($iconHandle)
		$formDoc.icon = $icon
#endregion formIcon

		# load dropdowns
		$cboOutputFormat.Items.Add("Microsoft Word") | Out-Null
		$cboOutputFormat.Items.Add("PDF") | Out-Null
		$cboOutputFormat.Items.Add("Formatted Text") | Out-Null
		$cboOutputFormat.Items.Add("HTML") | Out-Null
		$cboOutputFormat.DropDownStyle = [System.Windows.Forms.ComboBoxStyle]::DropDownList
		$cboOutputFormat.SelectedIndex = 0
		
		# set up event handlers
		$btnExit.Add_Click({Abort_Script})
		$btnGenerate.Add_Click({Continue_Script})
		$cboOutputFormat.add_SelectedIndexChanged({cboOutputFormat_SelectedIndexChanged})
		$btnSelectInputFile.Add_Click({selectFile})
		$btnSelectOutputDir.Add_Click({populateDirectory})
		
		# automatically configure the form depending on whether variables have been defined
		# if $ComputerName is defined, accept a target computer name, otherwise,
		# if $InputFile is defined, accept an input file name, otherwise,
		# hide BOTH groups and move fields up for better spacing on the form
		If(Test-Path variable:ComputerName) {
			$grpTarget.Visible = $True
		} ElseIf (Test-Path variable:InputFile) {
			$grpInput.Visible  = $True
		} Else {
			$grpOutput.Top = $grpOutput.Top - 60			
			$grpUserInfo.Top = $grpUserInfo.Top - 40			
			$grpOptional.Top = $grpOptional.Top - 20		
		}
		# now do the same for the $Hardware and $Software variables
		If(!(Test-Path variable:Hardware)) {
			$chkHardware.Visible = $False
			$chkSoftware.Top = $chkSoftware.Top - 24
			$grpOptional.Height = $grpOptional.Height - 20
			$btnGenerate.Top = $btnGenerate.Top - 16
			$btnExit.Top = $btnExit.Top - 16
			$formDoc.Height = $formDoc.Height - 15
		}
		If(!(Test-Path variable:Software)) {
			$chkSoftware.Visible = $False
			$grpOptional.Height = $grpOptional.Height - 20
			$btnGenerate.Top = $btnGenerate.Top - 16
			$btnExit.Top = $btnExit.Top - 16
			$formDoc.Height = $formDoc.Height - 15
		}		
		[int] $Script:WordVersion = GetWordVersion
		[string] $Script:OSculture = (Get-Culture).Name.Substring(0,3)
		$lblCulture.Text = $Script:OSCulture
		
		# load the cover pages, based on Word version and culture
		$aCoverPages = GetCoverPages $Script:WordVersion $Script:OSculture
		# was a cover page passed as a parameter ?
		If (($Script:CoverPage -ne $Null) -and ($Script:CoverPage -ne "")) {
			$defaultCoverPage = $Script:CoverPage
		}
		foreach ($coverPage in $aCoverPages) {
			$cboCoverPage.Items.Add($coverPage) | Out-Null
			If ($coverPage -eq $defaultCoverPage) {
				$cboCoverPage.SelectedIndex = $cboCoverPage.Items.Count - 1
			}
		}
		# if no cover page set by default, set the first one
		If ($cboCoverPage.SelectedIndex -eq -1) {
			$cboCoverPage.SelectedIndex = 0
		}
		
		# load default values
		If ($Script:InputFile -ne "") {
			$txtInputFile.Text = $Script:InputFile
		}
		If ($Script:OutputFile -ne "") {
			$txtOutputFile.Text = $Script:OutputFile
		}
		$txtOutputDir.Text = $Script:OutputDir
		If ($Script:CompanyName -ne "") {
			$txtCompanyName.Text = $Script:CompanyName
		}
		If ($Script:UserName -ne "") {
			$txtUserName.Text = $Script:UserName
		}		
		
		$chkAddDate.Checked = ($Script:AddDateTime -eq $True)
		$chkHardware.Checked = ($Script:Hardware -eq $True)
		$chkSoftware.Checked = ($Script:Software -eq $True)
		
		# display the form
		[System.Windows.Forms.Application]::EnableVisualStyles()
		[System.Windows.Forms.Application]::Run($formDoc)

		Return $continueProcessing 
}

Function GetWordVersion {

	[int] $wordVersion = 0
	If((Test-Path  REGISTRY::HKEY_CLASSES_ROOT\Word.Application) -eq $False)
	{
		Return
	}
	$installedWordVer = (Get-ItemProperty -literalpath REGISTRY::HKEY_CLASSES_ROOT\Word.Application\CurVer).'(default)'
	$aWord = $installedWordVer.Split(".")
	$wordVersion = [int] $aWord[2]
	Return $wordVersion
}

Function GetCoverPages
{
	Param([int]$xWordVersion, [string]$CultureCode)
	
	$xArray = ""
	
	Switch ($CultureCode)
	{
		'ca-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Austin", "En bandes", "Faceta", "Filigrana",
					"Integral", "Ió (clar)", "Ió (fosc)", "Línia lateral",
					"Moviment", "Quadrícula", "Retrospectiu", "Sector (clar)",
					"Sector (fosc)", "Semàfor", "Visualització", "Whisp")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alfabet", "Anual", "Austin", "Conservador",
					"Contrast", "Cubicles", "Diplomàtic", "Exposició",
					"Línia lateral", "Mod", "Mosiac", "Moviment", "Paper de diari",
					"Perspectiva", "Piles", "Quadrícula", "Sobri",
					"Transcendir", "Trencaclosques")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabet", "Anual", "Conservador", "Contrast",
					"Cubicles", "Diplomàtic", "En mosaic", "Exposició", "Línia lateral",
					"Mod", "Moviment", "Piles", "Sobri", "Transcendir", "Trencaclosques")
				}
			}

		'da-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("BevægElse", "Brusen", "Ion (lys)", "Filigran",
					"Retro", "Semafor", "Visningsmaster", "Integral",
					"Facet", "Gitter", "Stribet", "Sidelinje", "Udsnit (lys)",
					"Udsnit (mørk)", "Ion (mørk)", "Austin")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("BevægElse", "Moderat", "Perspektiv", "Firkanter",
					"Overskrid", "Alfabet", "Kontrast", "Stakke", "Fliser", "Gåde",
					"Gitter", "Austin", "Eksponering", "Sidelinje", "Enkel",
					"Nålestribet", "Årlig", "Avispapir", "Tradionel")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabet", "Årlig", "BevægElse", "Eksponering",
					"Enkel", "Firkanter", "Fliser", "Gåde", "Kontrast",
					"Mod", "Nålestribet", "Overskrid", "Sidelinje", "Stakke",
					"Tradionel")
				}
			}

		'de-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Semaphor", "Segment (hell)", "Ion (hell)",
					"Raster", "Ion (dunkel)", "Filigran", "Rückblick", "Pfiff",
					"ViewMaster", "Segment (dunkel)", "Verbunden", "Bewegung",
					"Randlinie", "Austin", "Integral", "Facette")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alphabet", "Austin", "Bewegung", "Durchscheinend",
					"Herausgestellt", "Jährlich", "Kacheln", "Kontrast", "Kubistisch",
					"Modern", "Nadelstreifen", "Perspektive", "Puzzle", "Randlinie",
					"Raster", "Schlicht", "Stapel", "Traditionell", "Zeitungspapier")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alphabet", "Bewegung", "Durchscheinend", "Herausgestellt",
					"Jährlich", "Kacheln", "Kontrast", "Kubistisch", "Modern",
					"Nadelstreifen", "Puzzle", "Randlinie", "Raster", "Schlicht", "Stapel",
					"Traditionell")
				}
			}

		'en-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Austin", "Banded", "Facet", "Filigree", "Grid",
					"Integral", "Ion (Dark)", "Ion (Light)", "Motion", "Retrospect",
					"Semaphore", "Sideline", "Slice (Dark)", "Slice (Light)", "ViewMaster",
					"Whisp")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alphabet", "Annual", "Austere", "Austin", "Conservative",
					"Contrast", "Cubicles", "Exposure", "Grid", "Mod", "Motion", "Newsprint",
					"Perspective", "Pinstripes", "Puzzle", "Sideline", "Stacks", "Tiles", "Transcend")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alphabet", "Annual", "Austere", "Conservative", "Contrast",
					"Cubicles", "Exposure", "Mod", "Motion", "Pinstripes", "Puzzle",
					"Sideline", "Stacks", "Tiles", "Transcend")
				}
			}

		'es-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Whisp", "Vista principal", "Filigrana", "Austin",
					"Slice (luz)", "Faceta", "Semáforo", "Retrospectiva", "Cuadrícula",
					"Movimiento", "Cortar (oscuro)", "Línea lateral", "Ion (oscuro)",
					"Ion (claro)", "Integral", "Con bandas")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alfabeto", "Anual", "Austero", "Austin", "Conservador",
					"Contraste", "Cuadrícula", "Cubículos", "Exposición", "Línea lateral",
					"Moderno", "Mosaicos", "Movimiento", "Papel periódico",
					"Perspectiva", "Pilas", "Puzzle", "Rayas", "Sobrepasar")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabeto", "Anual", "Austero", "Conservador",
					"Contraste", "Cubículos", "Exposición", "Línea lateral",
					"Moderno", "Mosaicos", "Movimiento", "Pilas", "Puzzle",
					"Rayas", "Sobrepasar")
				}
			}

		'fi-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Filigraani", "Integraali", "Ioni (tumma)",
					"Ioni (vaalea)", "Opastin", "Pinta", "Retro", "Sektori (tumma)",
					"Sektori (vaalea)", "Vaihtuvavärinen", "ViewMaster", "Austin",
					"Kiehkura", "Liike", "Ruudukko", "Sivussa")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Aakkoset", "Askeettinen", "Austin", "Kontrasti",
					"Laatikot", "Liike", "Liituraita", "Mod", "Osittain peitossa",
					"Palapeli", "Perinteinen", "Perspektiivi", "Pinot", "Ruudukko",
					"Ruudut", "Sanomalehtipaperi", "Sivussa", "Vuotuinen", "Ylitys")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Aakkoset", "Alttius", "Kontrasti", "Kuvakkeet ja tiedot",
					"Liike" , "Liituraita" , "Mod" , "Palapeli", "Perinteinen", "Pinot",
					"Sivussa", "Työpisteet", "Vuosittainen", "Yksinkertainen", "Ylitys")
				}
			}

		'fr-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("ViewMaster", "Secteur (foncé)", "Sémaphore",
					"Rétrospective", "Ion (foncé)", "Ion (clair)", "Intégrale",
					"Filigrane", "Facette", "Secteur (clair)", "À bandes", "Austin",
					"Guide", "Whisp", "Lignes latérales", "Quadrillage")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Mosaïques", "Ligne latérale", "Annuel", "Perspective",
					"Contraste", "Emplacements de bureau", "Moderne", "Blocs empilés",
					"Rayures fines", "Austère", "Transcendant", "Classique", "Quadrillage",
					"Exposition", "Alphabet", "Mots croisés", "Papier journal", "Austin", "Guide")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alphabet", "Annuel", "Austère", "Blocs empilés", "Blocs superposés",
					"Classique", "Contraste", "Exposition", "Guide", "Ligne latérale", "Moderne",
					"Mosaïques", "Mots croisés", "Rayures fines", "Transcendant")
				}
			}

		'nb-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Austin", "BevegElse", "Dempet", "Fasett", "Filigran",
					"Integral", "Ion (lys)", "Ion (mørk)", "Retrospekt", "Rutenett",
					"Sektor (lys)", "Sektor (mørk)", "Semafor", "Sidelinje", "Stripet",
					"ViewMaster")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alfabet", "Årlig", "Avistrykk", "Austin", "Avlukker",
					"BevegElse", "Engasjement", "Enkel", "Fliser", "Konservativ",
					"Kontrast", "Mod", "Perspektiv", "Puslespill", "Rutenett", "Sidelinje",
					"Smale striper", "Stabler", "Transcenderende")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabet", "Årlig", "Avlukker", "BevegElse", "Engasjement",
					"Enkel", "Fliser", "Konservativ", "Kontrast", "Mod", "Puslespill",
					"Sidelinje", "Smale striper", "Stabler", "Transcenderende")
				}
			}

		'nl-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Austin", "Beweging", "Facet", "Filigraan", "Gestreept",
					"Integraal", "Ion (donker)", "Ion (licht)", "Raster",
					"Segment (Light)", "Semafoor", "Slice (donker)", "Spriet",
					"Terugblik", "Terzijde", "ViewMaster")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Aantrekkelijk", "Alfabet", "Austin", "Bescheiden",
					"Beweging", "Blikvanger", "Contrast", "Eenvoudig", "Jaarlijks",
					"Krantenpapier", "Krijtstreep", "Kubussen", "Mod", "Perspectief",
					"Puzzel", "Raster", "Stapels",
					"Tegels", "Terzijde")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Aantrekkelijk", "Alfabet", "Bescheiden", "Beweging",
					"Blikvanger", "Contrast", "Eenvoudig", "Jaarlijks", "Krijtstreep",
					"Mod", "Puzzel", "Stapels", "Tegels", "Terzijde", "Werkplekken")
				}
			}

		'pt-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Animação", "Austin", "Em Tiras", "Exibição Mestra",
					"Faceta", "Fatia (Clara)", "Fatia (Escura)", "Filete", "Filigrana",
					"Grade", "Integral", "Íon (Claro)", "Íon (Escuro)", "Linha Lateral",
					"Retrospectiva", "Semáforo")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alfabeto", "Animação", "Anual", "Austero", "Austin", "Baias",
					"Conservador", "Contraste", "Exposição", "Grade", "Ladrilhos",
					"Linha Lateral", "Listras", "Mod", "Papel Jornal", "Perspectiva", "Pilhas",
					"Quebra-cabeça", "Transcend")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabeto", "Animação", "Anual", "Austero", "Baias", "Conservador",
					"Contraste", "Exposição", "Ladrilhos", "Linha Lateral", "Listras", "Mod",
					"Pilhas", "Quebra-cabeça", "Transcendente")
				}
			}

		'sv-'	{
				If($xWordVersion -eq $wdWord2013)
				{
					$xArray = ("Austin", "Band", "Fasett", "Filigran", "Integrerad", "Jon (ljust)",
					"Jon (mörkt)", "Knippe", "Rutnät", "RörElse", "Sektor (ljus)", "Sektor (mörk)",
					"Semafor", "Sidlinje", "VisaHuvudsida", "Återblick")
				}
				ElseIf($xWordVersion -eq $wdWord2010)
				{
					$xArray = ("Alfabetmönster", "Austin", "Enkelt", "Exponering", "Konservativt",
					"Kontrast", "Kritstreck", "Kuber", "Perspektiv", "Plattor", "Pussel", "Rutnät",
					"RörElse", "Sidlinje", "Sobert", "Staplat", "Tidningspapper", "Årligt",
					"Övergående")
				}
				ElseIf($xWordVersion -eq $wdWord2007)
				{
					$xArray = ("Alfabetmönster", "Årligt", "Enkelt", "Exponering", "Konservativt",
					"Kontrast", "Kritstreck", "Kuber", "Övergående", "Plattor", "Pussel", "RörElse",
					"Sidlinje", "Sobert", "Staplat")
				}
			}

		Default	{
					If($xWordVersion -eq $wdWord2013)
					{
						$xArray = ("Austin", "Banded", "Facet", "Filigree", "Grid", "Integral",
						"Ion (Dark)", "Ion (Light)", "Motion", "Retrospect", "Semaphore",
						"Sideline", "Slice (Dark)", "Slice (Light)", "ViewMaster", "Whisp")
					}
					ElseIf($xWordVersion -eq $wdWord2010)
					{
						$xArray = ("Alphabet", "Annual", "Austere", "Austin", "Conservative",
						"Contrast", "Cubicles", "Exposure", "Grid", "Mod", "Motion", "Newsprint",
						"Perspective", "Pinstripes", "Puzzle", "Sideline", "Stacks", "Tiles", "Transcend")
					}
					ElseIf($xWordVersion -eq $wdWord2007)
					{
						$xArray = ("Alphabet", "Annual", "Austere", "Conservative", "Contrast",
						"Cubicles", "Exposure", "Mod", "Motion", "Pinstripes", "Puzzle",
						"Sideline", "Stacks", "Tiles", "Transcend")
					}
				}
	}
	
	Return $xArray
}

Function ValidateCompanyName
{
	[bool]$xResult = Test-RegistryValue "HKCU:\Software\Microsoft\Office\Common\UserInfo" "CompanyName"
	If($xResult)
	{
		Return Get-RegistryValue "HKCU:\Software\Microsoft\Office\Common\UserInfo" "CompanyName"
	}
	Else
	{
		$xResult = Test-RegistryValue "HKCU:\Software\Microsoft\Office\Common\UserInfo" "Company"
		If($xResult)
		{
			Return Get-RegistryValue "HKCU:\Software\Microsoft\Office\Common\UserInfo" "Company"
		}
		Else
		{
			Return ""
		}
	}
}

#http://stackoverflow.com/questions/5648931/test-if-registry-value-exists
# This Function just gets $True or $False
Function Test-RegistryValue($path, $name)
{
	$key = Get-Item -LiteralPath $path -EA 0
	$key -and $Null -ne $key.GetValue($name, $Null)
}

# Gets the specified registry value or $Null if it is missing
Function Get-RegistryValue($path, $name)
{
	$key = Get-Item -LiteralPath $path -EA 0
	If($key)
	{
		$key.GetValue($name, $Null)
	}
	Else
	{
		$Null
	}
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#  End of GUI for documentation scripts
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#endregion Documentation GUI

#~~< Constants - from: >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#http://groovy.codehaus.org/modules/scriptom/1.6.0/scriptom-office-2K3-tlb/apidocs/
	#http://msdn.microsoft.com/en-us/library/office/aa211923(v=office.11).aspx
	[int]$wdAlignPageNumberRight = 2
	[long]$wdColorGray15 = 14277081
	[long]$wdColorGray05 = 15987699 
	[int]$wdMove = 0
	[int]$wdSeekMainDocument = 0
	[int]$wdSeekPrimaryFooter = 4
	[int]$wdStory = 6
	[int]$wdColorRed = 255
	[int]$wdColorBlack = 0
	[int]$wdWord2007 = 12
	[int]$wdWord2010 = 14
	[int]$wdWord2013 = 15
	[int]$wdFormatDocumentDefault = 16
	[int]$wdFormatPDF = 17
	#http://blogs.technet.com/b/heyscriptingguy/archive/2006/03/01/how-can-i-right-align-a-single-column-in-a-word-table.aspx
	#http://msdn.microsoft.com/en-us/library/office/ff835817%28v=office.15%29.aspx
	[int]$wdAlignParagraphLeft = 0
	[int]$wdAlignParagraphCenter = 1
	[int]$wdAlignParagraphRight = 2
	#http://msdn.microsoft.com/en-us/library/office/ff193345%28v=office.15%29.aspx
	[int]$wdCellAlignVerticalTop = 0
	[int]$wdCellAlignVerticalCenter = 1
	[int]$wdCellAlignVerticalBottom = 2
	#http://msdn.microsoft.com/en-us/library/office/ff844856%28v=office.15%29.aspx
	[int]$wdAutoFitFixed = 0
	[int]$wdAutoFitContent = 1
	[int]$wdAutoFitWindow = 2
	#http://msdn.microsoft.com/en-us/library/office/ff821928%28v=office.15%29.aspx
	[int]$wdAdjustNone = 0
	[int]$wdAdjustProportional = 1
	[int]$wdAdjustFirstColumn = 2
	[int]$wdAdjustSameWidth = 3

	[int]$PointsPerTabStop = 36
	[int]$Indent0TabStops = 0 * $PointsPerTabStop
	[int]$Indent1TabStops = 1 * $PointsPerTabStop
	[int]$Indent2TabStops = 2 * $PointsPerTabStop
	[int]$Indent3TabStops = 3 * $PointsPerTabStop
	[int]$Indent4TabStops = 4 * $PointsPerTabStop

	# http://www.thedoctools.com/index.php?show=wt_style_names_english_danish_german_french
	[int]$wdStyleHeading1 = -2
	[int]$wdStyleHeading2 = -3
	[int]$wdStyleHeading3 = -4
	[int]$wdStyleHeading4 = -5
	[int]$wdStyleNoSpacing = -158
	[int]$wdTableGrid = -155

	#http://groovy.codehaus.org/modules/scriptom/1.6.0/scriptom-office-2K3-tlb/apidocs/org/codehaus/groovy/scriptom/tlb/office/word/WdLineStyle.html
	[int]$wdLineStyleNone = 0
	[int]$wdLineStyleSingle = 1

	[int]$wdHeadingFormatTrue = -1
	[int]$wdHeadingFormatFalse = 0 

	[string]$RunningOS = (Get-WmiObject -class Win32_OperatingSystem -EA 0).Caption
	
#~~< HTML Colors >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Set htmlredmask         -Option AllScope -Value "#FF0000" 4>$Null
    Set htmlcyanmask        -Option AllScope -Value "#00FFFF" 4>$Null
    Set htmlbluemask        -Option AllScope -Value "#0000FF" 4>$Null
    Set htmldarkbluemask    -Option AllScope -Value "#0000A0" 4>$Null
    Set htmllightbluemask   -Option AllScope -Value "#ADD8E6" 4>$Null
    Set htmlpurplemask      -Option AllScope -Value "#800080" 4>$Null
    Set htmlyellowmask      -Option AllScope -Value "#FFFF00" 4>$Null
    Set htmllimemask        -Option AllScope -Value "#00FF00" 4>$Null
    Set htmlmagentamask     -Option AllScope -Value "#FF00FF" 4>$Null
    Set htmlwhitemask       -Option AllScope -Value "#FFFFFF" 4>$Null
    Set htmlsilvermask      -Option AllScope -Value "#C0C0C0" 4>$Null
    Set htmlgraymask        -Option AllScope -Value "#808080" 4>$Null
    Set htmlblackmask       -Option AllScope -Value "#000000" 4>$Null
    Set htmlorangemask      -Option AllScope -Value "#FFA500" 4>$Null
    Set htmlmaroonmask      -Option AllScope -Value "#800000" 4>$Null
    Set htmlgreenmask       -Option AllScope -Value "#008000" 4>$Null
    Set htmlolivemask       -Option AllScope -Value "#808000" 4>$Null

    Set htmlbold        -Option AllScope -Value 1 4>$Null
    Set htmlitalics     -Option AllScope -Value 2 4>$Null
    Set htmlred         -Option AllScope -Value 4 4>$Null
    Set htmlcyan        -Option AllScope -Value 8 4>$Null
    Set htmlblue        -Option AllScope -Value 16 4>$Null
    Set htmldarkblue    -Option AllScope -Value 32 4>$Null
    Set htmllightblue   -Option AllScope -Value 64 4>$Null
    Set htmlpurple      -Option AllScope -Value 128 4>$Null
    Set htmlyellow      -Option AllScope -Value 256 4>$Null
    Set htmllime        -Option AllScope -Value 512 4>$Null
    Set htmlmagenta     -Option AllScope -Value 1024 4>$Null
    Set htmlwhite       -Option AllScope -Value 2048 4>$Null
    Set htmlsilver      -Option AllScope -Value 4096 4>$Null
    Set htmlgray        -Option AllScope -Value 8192 4>$Null
    Set htmlolive       -Option AllScope -Value 16384 4>$Null
    Set htmlorange      -Option AllScope -Value 32768 4>$Null
    Set htmlmaroon      -Option AllScope -Value 65536 4>$Null
    Set htmlgreen       -Option AllScope -Value 131072 4>$Null
    Set htmlblack       -Option AllScope -Value 262144 4>$Null
	
#~~< pre-GUI script processing begins here >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If($GUI -eq $True)
{
	# if Company Name not passed, get it from the registry
	If(($CompanyName -eq $Null) -or ($CompanyName -eq ""))
	{
		Write-Verbose "$(Get-Date): Getting company name from registry"
		$CompanyName = ValidateCompanyName
	}

	Write-Verbose "$(Get-Date):"
	Write-Verbose "$(Get-Date): Loading GUI ..."
	$continue = ProcessGUI
	If ($continue -eq $False) 
	{ 
		Write-Verbose "$(Get-Date): Cancelled by user"
		Return 
	} 
}

Write-Verbose "$(Get-Date): Returning from GUI ..."
Write-Verbose "$(Get-Date):"

If($MSWord)
{
	Write-Verbose "$(Get-Date): Output format is MS Word"
}
ElseIf($PDF)
{
	Write-Verbose "$(Get-Date): Output format is PDF"
}
ElseIf($Text)
{
	Write-Verbose "$(Get-Date): Output format is Text"
}
ElseIf($HTML)
{
	Write-Verbose "$(Get-Date): Output format is HTML"
}
Else
{
	$ErrorActionPreference = $SaveEAPreference
	Write-Verbose "$(Get-Date): Unable to determine output parameter"
	If($MSWord -eq $Null)
	{
		Write-Verbose "$(Get-Date): MSWord is Null"
	}
	ElseIf($PDF -eq $Null)
	{
		Write-Verbose "$(Get-Date): PDF is Null"
	}
	ElseIf($Text -eq $Null)
	{
		Write-Verbose "$(Get-Date): Text is Null"
	}
	ElseIf($HTML -eq $Null)
	{
		Write-Verbose "$(Get-Date): HTML is Null"
	}
	Else
	{
		Write-Verbose "$(Get-Date): MSWord is $($MSWord)"
		Write-Verbose "$(Get-Date): PDF is $($PDF)"
		Write-Verbose "$(Get-Date): Text is $($Text)"
		Write-Verbose "$(Get-Date): HTML is $($HTML)"
	}
	Write-Error "Unable to determine output parameter.  Script cannot continue"
	Exit
}

If($MSWord -or $PDF)
{
	#try and fix the issue with the $CompanyName variable
	$CoName = $CompanyName
	Write-Verbose "$(Get-Date): CoName is $($CoName)"
}

Function SetWordHashTable
{
	Param([string]$CultureCode)

	#optimized by Michael B. SMith
	
	# DE and FR translations for Word 2010 by Vladimir Radojevic
	# Vladimir.Radojevic@Commerzreal.com

	# DA translations for Word 2010 by Thomas Daugaard
	# Citrix Infrastructure Specialist at edgemo A/S

	# CA translations by Javier Sanchez 
	# CEO & Founder 101 Consulting

	#ca - Catalan
	#da - Danish
	#de - German
	#en - English
	#es - Spanish
	#fi - Finnish
	#fr - French
	#nb - Norwegian
	#nl - Dutch
	#pt - Portuguese
	#sv - Swedish

	[string]$toc = $(
		Switch ($CultureCode)
		{
			'ca-'	{ 'Taula automática 2' }

			'da-'	{ 'Automatisk tabel 2' }

			'de-'	{ 'Automatische Tabelle 2' }

			'en-'	{ 'Automatic Table 2' }

			'es-'	{ 'Tabla automática 2' }

			'fi-'	{ 'Automaattinen taulukko 2' }

			'fr-'	{ 'Sommaire Automatique 2' }

			'nb-'	{ 'Automatisk tabell 2' }

			'nl-'	{ 'Automatische inhoudsopgave 2' }

			'pt-'	{ 'Sumário Automático 2' }

			'sv-'	{ 'Automatisk innehållsförteckning2' }
		}
	)

	$Script:myHash                      = @{}
	$Script:myHash.Word_TableOfContents = $toc
	$Script:myHash.Word_NoSpacing       = $wdStyleNoSpacing
	$Script:myHash.Word_Heading1        = $wdStyleheading1
	$Script:myHash.Word_Heading2        = $wdStyleheading2
	$Script:myHash.Word_Heading3        = $wdStyleheading3
	$Script:myHash.Word_Heading4        = $wdStyleheading4
	$Script:myHash.Word_TableGrid       = $wdTableGrid
}

Function GetCulture
{
	Param([int]$WordValue)
	
	#codes obtained from http://support.microsoft.com/kb/221435
	#http://msdn.microsoft.com/en-us/library/bb213877(v=office.12).aspx
	$CatalanArray = 1027
	$DanishArray = 1030
	$DutchArray = 2067, 1043
	$EnglishArray = 3081, 10249, 4105, 9225, 6153, 8201, 5129, 13321, 7177, 11273, 2057, 1033, 12297
	$FinnishArray = 1035
	$FrenchArray = 2060, 1036, 11276, 3084, 12300, 5132, 13324, 6156, 8204, 10252, 7180, 9228, 4108
	$GermanArray = 1031, 3079, 5127, 4103, 2055
	$NorwegianArray = 1044, 2068
	$PortugueseArray = 1046, 2070
	$SpanishArray = 1034, 11274, 16394, 13322, 9226, 5130, 7178, 12298, 17418, 4106, 18442, 19466, 6154, 15370, 10250, 20490, 3082, 14346, 8202
	$SwedishArray = 1053, 2077

	#ca - Catalan
	#da - Danish
	#de - German
	#en - English
	#es - Spanish
	#fi - Finnish
	#fr - French
	#nb - Norwegian
	#nl - Dutch
	#pt - Portuguese
	#sv - Swedish

	Switch ($WordValue)
	{
		{$CatalanArray -contains $_} {$CultureCode = "ca-"}
		{$DanishArray -contains $_} {$CultureCode = "da-"}
		{$DutchArray -contains $_} {$CultureCode = "nl-"}
		{$EnglishArray -contains $_} {$CultureCode = "en-"}
		{$FinnishArray -contains $_} {$CultureCode = "fi-"}
		{$FrenchArray -contains $_} {$CultureCode = "fr-"}
		{$GermanArray -contains $_} {$CultureCode = "de-"}
		{$NorwegianArray -contains $_} {$CultureCode = "nb-"}
		{$PortugueseArray -contains $_} {$CultureCode = "pt-"}
		{$SpanishArray -contains $_} {$CultureCode = "es-"}
		{$SwedishArray -contains $_} {$CultureCode = "sv-"}
		Default {$CultureCode = "en-"}
	}
	
	Return $CultureCode
}

Function ValidateCoverPage
{
	Param([int]$xWordVersion, [string]$xCP, [string]$CultureCode)
	
	$xArray = GetCoverPages $xWordVersion $CultureCode
	
	If($xArray -contains $xCP)
	{
		$xArray = $Null
		Return $True
	}
	Else
	{
		$xArray = $Null
		Return $False
	}
}

Function CheckWordPrereq
{
	If((Test-Path  REGISTRY::HKEY_CLASSES_ROOT\Word.Application) -eq $False)
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Host "`n`n`t`tThis script directly outputs to Microsoft Word, please install Microsoft Word`n`n"
		Exit
	}

	#find out our session (usually "1" except on TS/RDC or Citrix)
	$SessionID = (Get-Process -PID $PID).SessionId
	
	#Find out if winword is running in our session
	[bool]$wordrunning = ((Get-Process 'WinWord' -ea 0)|?{$_.SessionId -eq $SessionID}) -ne $Null
	If($wordrunning)
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Host "`n`n`tPlease close all instances of Microsoft Word before running this report.`n`n"
		Exit
	}
}

Function line
#function created by Michael B. Smith, Exchange MVP
#@essentialexchange on Twitter
#http://TheEssentialExchange.com
#for creating the formatted text report
#created March 2011
#updated March 2014
{
	Param( [int]$tabs = 0, [string]$name = '', [string]$value = '', [string]$newline = "`r`n", [switch]$nonewline )
	While( $tabs -gt 0 ) { $Global:Output += "`t"; $tabs--; }
	If( $nonewline )
	{
		$Global:Output += $name + $value
	}
	Else
	{
		$Global:Output += $name + $value + $newline
	}
}
	
Function WriteWordLine
#Function created by Ryan Revord
#@rsrevord on Twitter
#Function created to make output to Word easy in this script
#updated 27-Mar-2014 to include font name, font size, italics and bold options
{
	Param([int]$style=0, 
	[int]$tabs = 0, 
	[string]$name = '', 
	[string]$value = '', 
	[string]$fontName=$Null,
	[int]$fontSize=0,
	[bool]$italics=$False,
	[bool]$boldface=$False,
	[Switch]$nonewline)
	
	#Build output style
	[string]$output = ""
	Switch ($style)
	{
		0 {$Script:Selection.Style = $Script:MyHash.Word_NoSpacing}
		1 {$Script:Selection.Style = $Script:MyHash.Word_Heading1}
		2 {$Script:Selection.Style = $Script:MyHash.Word_Heading2}
		3 {$Script:Selection.Style = $Script:MyHash.Word_Heading3}
		4 {$Script:Selection.Style = $Script:MyHash.Word_Heading4}
		Default {$Script:Selection.Style = $Script:MyHash.Word_NoSpacing}
	}
	
	#build # of tabs
	While($tabs -gt 0)
	{ 
		$output += "`t"; $tabs--; 
	}
 
	If(![String]::IsNullOrEmpty($fontName)) 
	{
		$Script:Selection.Font.name = $fontName
	} 

	If($fontSize -ne 0) 
	{
		$Script:Selection.Font.size = $fontSize
	} 
 
	If($italics -eq $True) 
	{
		$Script:Selection.Font.Italic = $True
	} 
 
	If($boldface -eq $True) 
	{
		$Script:Selection.Font.Bold = $True
	} 

	#output the rest of the parameters.
	$output += $name + $value
	$Script:Selection.TypeText($output)
 
	#test for new WriteWordLine 0.
	If($nonewline)
	{
		# Do nothing.
	} 
	Else 
	{
		$Script:Selection.TypeParagraph()
	}
}

Function _SetDocumentProperty 
{
	#jeff hicks
	Param([object]$Properties,[string]$Name,[string]$Value)
	#get the property object
	$prop = $properties | ForEach { 
		$propname=$_.GetType().InvokeMember("Name","GetProperty",$Null,$_,$Null)
		If($propname -eq $Name) 
		{
			Return $_
		}
	} #ForEach

	#set the value
	$Prop.GetType().InvokeMember("Value","SetProperty",$Null,$prop,$Value)
}

Function AbortScript
{
	$Script:Word.quit()
	Write-Verbose "$(Get-Date): System Cleanup"
	[System.Runtime.Interopservices.Marshal]::ReleaseComObject($Script:Word) | Out-Null
	If(Test-Path variable:global:word)
	{
		Remove-Variable -Name word -Scope Global
	}
	[gc]::collect() 
	[gc]::WaitForPendingFinalizers()
	Write-Verbose "$(Get-Date): Script has been aborted"
	$ErrorActionPreference = $SaveEAPreference
	Exit
}

Function FindWordDocumentEnd
{
	#return focus to main document    
	$Script:Doc.ActiveWindow.ActivePane.view.SeekView = $wdSeekMainDocument
	#move to the end of the current document
	$Script:Selection.EndKey($wdStory,$wdMove) | Out-Null
}

<#
.Synopsis
	Add a table to a Microsoft Word document
.DESCRIPTION
	This function adds a table to a Microsoft Word document from either an array of
	Hashtables or an array of PSCustomObjects.

	Using this function is quicker than setting each table cell individually but can
	only utilise the built-in MS Word table autoformats. Individual tables cells can
	be altered after the table has been appended to the document (a table reference
	is returned).
.EXAMPLE
	AddWordTable -Hashtable $HashtableArray

	This example adds table to the MS Word document, utilising all key/value pairs in
	the array of hashtables. Column headers will display the key names as defined.
	Note: the columns might not be displayed in the order that they were defined. To
	ensure columns are displayed in the required order utilise the -Columns parameter.
.EXAMPLE
	AddWordTable -Hashtable $HashtableArray -List

	This example adds table to the MS Word document, utilising all key/value pairs in
	the array of hashtables. No column headers will be added, in a ListView format.
	Note: the columns might not be displayed in the order that they were defined. To
	ensure columns are displayed in the required order utilise the -Columns parameter.
.EXAMPLE
	AddWordTable -CustomObject $PSCustomObjectArray

	This example adds table to the MS Word document, utilising all note property names
	the array of PSCustomObjects. Column headers will display the note property names.
	Note: the columns might not be displayed in the order that they were defined. To
	ensure columns are displayed in the required order utilise the -Columns parameter.
.EXAMPLE
	AddWordTable -Hashtable $HashtableArray -Columns FirstName,LastName,EmailAddress

	This example adds a table to the MS Word document, but only using the specified
	key names: FirstName, LastName and EmailAddress. If other keys are present in the
	array of Hashtables they will be ignored.
.EXAMPLE
	AddWordTable -CustomObject $PSCustomObjectArray -Columns FirstName,LastName,EmailAddress -Headers "First Name","Last Name","Email Address"

	This example adds a table to the MS Word document, but only using the specified
	PSCustomObject note properties: FirstName, LastName and EmailAddress. If other note
	properties are present in the array of PSCustomObjects they will be ignored. The
	display names for each specified column header has been overridden to display a
	custom header. Note: the order of the header names must match the specified columns.
#>
Function AddWordTable
{
	[CmdletBinding()]
	Param
	(
		# Array of Hashtable (including table headers)
		[Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, ParameterSetName='Hashtable', Position=0)]
		[ValidateNotNullOrEmpty()] [System.Collections.Hashtable[]] $Hashtable,
		# Array of PSCustomObjects
		[Parameter(Mandatory=$true, ValueFromPipelineByPropertyName=$true, ParameterSetName='CustomObject', Position=0)]
		[ValidateNotNullOrEmpty()] [PSCustomObject[]] $CustomObject,
		# Array of Hashtable key names or PSCustomObject property names to include, in display order.
		# If not supplied then all Hashtable keys or all PSCustomObject properties will be displayed.
		[Parameter(ValueFromPipelineByPropertyName=$true)] [AllowNull()] [string[]] $Columns = $null,
		# Array of custom table header strings in display order.
		[Parameter(ValueFromPipelineByPropertyName=$true)] [AllowNull()] [string[]] $Headers = $null,
		# AutoFit table behavior.
		[Parameter(ValueFromPipelineByPropertyName=$true)] [AllowNull()] [int] $AutoFit = -1,
		# List view (no headers)
		[Switch] $List,
		# Grid lines
		[Switch] $NoGridLines,
		# Built-in Word table formatting style constant
		# Would recommend only $wdTableFormatContempory for normal usage (possibly $wdTableFormatList5 for List view)
		[Parameter(ValueFromPipelineByPropertyName=$true)] [int] $Format = 0
	)

	Begin 
	{
		Write-Debug ("Using parameter set '{0}'" -f $PSCmdlet.ParameterSetName);
		## Check if -Columns wasn't specified but -Headers were (saves some additional parameter sets!)
		If(($Columns -eq $null) -and ($Headers -ne $null)) 
		{
			Write-Warning "No columns specified and therefore, specified headers will be ignored.";
			$Columns = $null;
		}
		ElseIf(($Columns -ne $null) -and ($Headers -ne $null)) 
		{
			## Check if number of specified -Columns matches number of specified -Headers
			If($Columns.Length -ne $Headers.Length) 
			{
				Write-Error "The specified number of columns does not match the specified number of headers.";
			}
		} ## end elseif
	} ## end Begin

	Process
	{
		## Build the Word table data string to be converted to a range and then a table later.
        [System.Text.StringBuilder] $WordRangeString = New-Object System.Text.StringBuilder;

		Switch ($PSCmdlet.ParameterSetName) 
		{
			'CustomObject' 
			{
				If($Columns -eq $null) 
				{
					## Build the available columns from all availble PSCustomObject note properties
					[string[]] $Columns = @();
					## Add each NoteProperty name to the array
					ForEach($Property in ($CustomObject | Get-Member -MemberType NoteProperty)) 
					{ 
						$Columns += $Property.Name; 
					}
				}

				## Add the table headers from -Headers or -Columns (except when in -List(view)
				If(-not $List) 
				{
					Write-Debug ("$(Get-Date): `t`tBuilding table headers");
					If($Headers -ne $null) 
					{
                        [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $Headers));
					}
					Else 
					{ 
                        [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $Columns));
					}
				}

				## Iterate through each PSCustomObject
				Write-Debug ("$(Get-Date): `t`tBuilding table rows");
				ForEach($Object in $CustomObject) 
				{
					$OrderedValues = @();
					## Add each row item in the specified order
					ForEach($Column in $Columns) 
					{ 
						$OrderedValues += $Object.$Column; 
					}
					## Use the ordered list to add each column in specified order
                    [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $OrderedValues));
				} ## end foreach
				Write-Debug ("$(Get-Date): `t`t`tAdded '{0}' table rows" -f ($CustomObject.Count));
			} ## end CustomObject

			Default 
			{   ## Hashtable
				If($Columns -eq $null) 
				{
					## Build the available columns from all available hashtable keys. Hopefully
					## all Hashtables have the same keys (they should for a table).
					$Columns = $Hashtable[0].Keys;
				}

				## Add the table headers from -Headers or -Columns (except when in -List(view)
				If(-not $List) 
				{
					Write-Debug ("$(Get-Date): `t`tBuilding table headers");
					If($Headers -ne $null) 
					{ 
                        [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $Headers));
					}
					Else 
					{
                        [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $Columns));
					}
				}
                
				## Iterate through each Hashtable
				Write-Debug ("$(Get-Date): `t`tBuilding table rows");
				ForEach($Hash in $Hashtable) 
				{
					$OrderedValues = @();
					## Add each row item in the specified order
					ForEach($Column in $Columns) 
					{ 
						$OrderedValues += $Hash.$Column; 
					}
					## Use the ordered list to add each column in specified order
                    [ref] $null = $WordRangeString.AppendFormat("{0}`n", [string]::Join("`t", $OrderedValues));
				} ## end foreach

				Write-Debug ("$(Get-Date): `t`t`tAdded '{0}' table rows" -f $Hashtable.Count);
			} ## end default
		} ## end switch

		## Create a MS Word range and set its text to our tab-delimited, concatenated string
		Write-Debug ("$(Get-Date): `t`tBuilding table range");
		$WordRange = $Script:Doc.Application.Selection.Range;
		$WordRange.Text = $WordRangeString.ToString();

		## Create hash table of named arguments to pass to the ConvertToTable method
		$ConvertToTableArguments = @{ Separator = [Microsoft.Office.Interop.Word.WdTableFieldSeparator]::wdSeparateByTabs; }

		## Negative built-in styles are not supported by the ConvertToTable method
		If($Format -ge 0) 
		{
			$ConvertToTableArguments.Add("Format", $Format);
			$ConvertToTableArguments.Add("ApplyBorders", $true);
			$ConvertToTableArguments.Add("ApplyShading", $true);
			$ConvertToTableArguments.Add("ApplyFont", $true);
			$ConvertToTableArguments.Add("ApplyColor", $true);
			If(!$List) 
			{ 
				$ConvertToTableArguments.Add("ApplyHeadingRows", $true); 
			}
			$ConvertToTableArguments.Add("ApplyLastRow", $true);
			$ConvertToTableArguments.Add("ApplyFirstColumn", $true);
			$ConvertToTableArguments.Add("ApplyLastColumn", $true);
		}

		## Invoke ConvertToTable method - with named arguments - to convert Word range to a table
		## See http://msdn.microsoft.com/en-us/library/office/aa171893(v=office.11).aspx
		Write-Debug ("$(Get-Date): `t`tConverting range to table");
		## Store the table reference just in case we need to set alternate row coloring
		$WordTable = $WordRange.GetType().InvokeMember(
			"ConvertToTable",                               # Method name
			[System.Reflection.BindingFlags]::InvokeMethod, # Flags
			$null,                                          # Binder
			$WordRange,                                     # Target (self!)
			([Object[]]($ConvertToTableArguments.Values)),  ## Named argument values
			$null,                                          # Modifiers
			$null,                                          # Culture
			([String[]]($ConvertToTableArguments.Keys))     ## Named argument names
		);

		## Implement grid lines (will wipe out any existing formatting
		If($Format -lt 0) 
		{
			Write-Debug ("$(Get-Date): `t`tSetting table format");
			$WordTable.Style = $Format;
		}

		## Set the table autofit behavior
		If($AutoFit -ne -1) 
		{ 
			$WordTable.AutoFitBehavior($AutoFit); 
		}

		#the next line causes the heading row to flow across page breaks
		$WordTable.Rows.First.Headingformat = $wdHeadingFormatTrue;

		If(!$NoGridLines) 
		{
			$WordTable.Borders.InsideLineStyle = $wdLineStyleSingle;
			$WordTable.Borders.OutsideLineStyle = $wdLineStyleSingle;
		}

		Return $WordTable;

	} ## end Process
}

<#
.Synopsis
	Sets the format of one or more Word table cells
.DESCRIPTION
	This function sets the format of one or more table cells, either from a collection
	of Word COM object cell references, an individual Word COM object cell reference or
	a hashtable containing Row and Column information.

	The font name, font size, bold, italic , underline and shading values can be used.
.EXAMPLE
	SetWordCellFormat -Hashtable $Coordinates -Table $TableReference -Bold

	This example sets all text to bold that is contained within the $TableReference
	Word table, using an array of hashtables. Each hashtable contain a pair of co-
	ordinates that is used to select the required cells. Note: the hashtable must
	contain the .Row and .Column key names. For example:
	@ { Row = 7; Column = 3 } to set the cell at row 7 and column 3 to bold.
.EXAMPLE
	$RowCollection = $Table.Rows.First.Cells
	SetWordCellFormat -Collection $RowCollection -Bold -Size 10

	This example sets all text to size 8 and bold for all cells that are contained
	within the first row of the table.
	Note: the $Table.Rows.First.Cells returns a collection of Word COM cells objects
	that are in the first table row.
.EXAMPLE
	$ColumnCollection = $Table.Columns.Item(2).Cells
	SetWordCellFormat -Collection $ColumnCollection -BackgroundColor 255

	This example sets the background (shading) of all cells in the table's second
	column to red.
	Note: the $Table.Columns.Item(2).Cells returns a collection of Word COM cells objects
	that are in the table's second column.
.EXAMPLE
	SetWordCellFormat -Cell $Table.Cell(17,3) -Font "Tahoma" -Color 16711680

	This example sets the font to Tahoma and the text color to blue for the cell located
	in the table's 17th row and 3rd column.
	Note: the $Table.Cell(17,3) returns a single Word COM cells object.
#>
Function SetWordCellFormat 
{
	[CmdletBinding(DefaultParameterSetName='Collection')]
	Param (
		# Word COM object cell collection reference
		[Parameter(Mandatory=$true, ValueFromPipeline=$true, ParameterSetName='Collection', Position=0)] [ValidateNotNullOrEmpty()] $Collection,
		# Word COM object individual cell reference
		[Parameter(Mandatory=$true, ParameterSetName='Cell', Position=0)] [ValidateNotNullOrEmpty()] $Cell,
		# Hashtable of cell co-ordinates
		[Parameter(Mandatory=$true, ParameterSetName='Hashtable', Position=0)] [ValidateNotNullOrEmpty()] [System.Collections.Hashtable[]] $Coordinates,
		# Word COM object table reference
		[Parameter(Mandatory=$true, ParameterSetName='Hashtable', Position=1)] [ValidateNotNullOrEmpty()] $Table,
		# Font name
		[Parameter()] [AllowNull()] [string] $Font = $null,
		# Font color
		[Parameter()] [AllowNull()] $Color = $null,
		# Font size
		[Parameter()] [ValidateNotNullOrEmpty()] [int] $Size = 0,
		# Cell background color
		[Parameter()] [AllowNull()] $BackgroundColor = $null,
		# Force solid background color
		[Switch] $Solid,
		[Switch] $Bold,
		[Switch] $Italic,
		[Switch] $Underline
	)

	Begin 
	{
		Write-Debug ("Using parameter set '{0}'." -f $PSCmdlet.ParameterSetName);
	}

	Process 
	{
		Switch ($PSCmdlet.ParameterSetName) 
		{
			'Collection' {
				ForEach($Cell in $Collection) 
				{
					If($BackgroundColor -ne $null) { $Cell.Shading.BackgroundPatternColor = $BackgroundColor; }
					If($Bold) { $Cell.Range.Font.Bold = $true; }
					If($Italic) { $Cell.Range.Font.Italic = $true; }
					If($Underline) { $Cell.Range.Font.Underline = 1; }
					If($Font -ne $null) { $Cell.Range.Font.Name = $Font; }
					If($Color -ne $null) { $Cell.Range.Font.Color = $Color; }
					If($Size -ne 0) { $Cell.Range.Font.Size = $Size; }
					If($Solid) { $Cell.Shading.Texture = 0; } ## wdTextureNone
				} # end foreach
			} # end Collection
			'Cell' 
			{
				If($Bold) { $Cell.Range.Font.Bold = $true; }
				If($Italic) { $Cell.Range.Font.Italic = $true; }
				If($Underline) { $Cell.Range.Font.Underline = 1; }
				If($Font -ne $null) { $Cell.Range.Font.Name = $Font; }
				If($Color -ne $null) { $Cell.Range.Font.Color = $Color; }
				If($Size -ne 0) { $Cell.Range.Font.Size = $Size; }
				If($BackgroundColor -ne $null) { $Cell.Shading.BackgroundPatternColor = $BackgroundColor; }
				If($Solid) { $Cell.Shading.Texture = 0; } ## wdTextureNone
			} # end Cell
			'Hashtable' 
			{
				ForEach($Coordinate in $Coordinates) 
				{
					$Cell = $Table.Cell($Coordinate.Row, $Coordinate.Column);
					If($Bold) { $Cell.Range.Font.Bold = $true; }
					If($Italic) { $Cell.Range.Font.Italic = $true; }
					If($Underline) { $Cell.Range.Font.Underline = 1; }
					If($Font -ne $null) { $Cell.Range.Font.Name = $Font; }
					If($Color -ne $null) { $Cell.Range.Font.Color = $Color; }
					If($Size -ne 0) { $Cell.Range.Font.Size = $Size; }
					If($BackgroundColor -ne $null) { $Cell.Shading.BackgroundPatternColor = $BackgroundColor; }
					If($Solid) { $Cell.Shading.Texture = 0; } ## wdTextureNone
				}
			} # end Hashtable
		} # end switch
	} # end process
}

<#
.Synopsis
	Sets alternate row colors in a Word table
.DESCRIPTION
	This function sets the format of alternate rows within a Word table using the
	specified $BackgroundColor. This function is expensive (in performance terms) as
	it recursively sets the format on alternate rows. It would be better to pick one
	of the predefined table formats (if one exists)? Obviously the more rows, the
	longer it takes :'(

	Note: this function is called by the AddWordTable function if an alternate row
	format is specified.
.EXAMPLE
	SetWordTableAlternateRowColor -Table $TableReference -BackgroundColor 255

	This example sets every-other table (starting with the first) row and sets the
	background color to red (wdColorRed).
.EXAMPLE
	SetWordTableAlternateRowColor -Table $TableReference -BackgroundColor 39423 -Seed Second

	This example sets every other table (starting with the second) row and sets the
	background color to light orange (weColorLightOrange).
#>
Function SetWordTableAlternateRowColor 
{
	[CmdletBinding()]
	Param (
		# Word COM object table reference
		[Parameter(Mandatory=$true, ValueFromPipeline=$true, Position=0)] [ValidateNotNullOrEmpty()] $Table,
		# Alternate row background color
		[Parameter(Mandatory=$true, Position=1)] [ValidateNotNull()] [int] $BackgroundColor,
		# Alternate row starting seed
		[Parameter(ValueFromPipelineByPropertyName=$true, Position=2)] [ValidateSet('First','Second')] [string] $Seed = 'First'
	)

	Process 
	{
		$StartDateTime = Get-Date;
		Write-Debug ("{0}: `t`tSetting alternate table row colors.." -f $StartDateTime);

		## Determine the row seed (only really need to check for 'Second' and default to 'First' otherwise
		If($Seed.ToLower() -eq 'second') 
		{ 
			$StartRowIndex = 2; 
		}
		Else 
		{ 
			$StartRowIndex = 1; 
		}

		For($AlternateRowIndex = $StartRowIndex; $AlternateRowIndex -lt $Table.Rows.Count; $AlternateRowIndex += 2) 
		{ 
			$Table.Rows.Item($AlternateRowIndex).Shading.BackgroundPatternColor = $BackgroundColor;
		}

		## I've put verbose calls in here we can see how expensive this functionality actually is.
		$EndDateTime = Get-Date;
		$ExecutionTime = New-TimeSpan -Start $StartDateTime -End $EndDateTime;
		Write-Debug ("{0}: `t`tDone setting alternate row style color in '{1}' seconds" -f $EndDateTime, $ExecutionTime.TotalSeconds);
	}
}

Function ShowScriptOptions
{
	Write-Verbose "$(Get-Date): "
	Write-Verbose "$(Get-Date): "
	Write-Verbose "$(Get-Date): Company Name : $($Script:CoName)"
	Write-Verbose "$(Get-Date): Cover Page   : $($CoverPage)"
	Write-Verbose "$(Get-Date): User Name    : $($UserName)"
	Write-Verbose "$(Get-Date): Save As PDF  : $($PDF)"
	Write-Verbose "$(Get-Date): Save As TEXT : $($TEXT)"
	Write-Verbose "$(Get-Date): Save As WORD : $($MSWORD)"
	Write-Verbose "$(Get-Date): Save As HTML : $($HTML)"
	Write-Verbose "$(Get-Date): Add DateTime : $($AddDateTime)"
	Write-Verbose "$(Get-Date): Filename1    : $($Script:FileName1)"
	If($PDF)
	{
		Write-Verbose "$(Get-Date): Filename2    : $($Script:FileName2)"
	}
	Write-Verbose "$(Get-Date): OS Detected  : $($RunningOS)"
	Write-Verbose "$(Get-Date): PSUICulture  : $($PSUICulture)"
	Write-Verbose "$(Get-Date): PSCulture    : $($PSCulture)"
	Write-Verbose "$(Get-Date): Word version : $($Script:WordProduct)"
	Write-Verbose "$(Get-Date): Word language: $($Script:WordLanguageValue)"
	Write-Verbose "$(Get-Date): PoSH version : $($Host.Version)"
	Write-Verbose "$(Get-Date): "
	Write-Verbose "$(Get-Date): Script start : $($Script:StartTime)"
	Write-Verbose "$(Get-Date): "
}

Function validStateProp( [object] $object, [string] $topLevel, [string] $secondLevel )
{
	#function created 8-jan-2014 by Michael B. Smith
	if( $object )
	{
		If( ( gm -Name $topLevel -InputObject $object ) )
		{
			If( ( gm -Name $secondLevel -InputObject $object.$topLevel ) )
			{
				Return $True
			}
		}
	}
	Return $False
}

Function SetupWord
{
	Write-Verbose "$(Get-Date): Setting up Word"
    
	# Setup word for output
	Write-Verbose "$(Get-Date): Create Word comObject.  Ignore the next message."
	$Script:Word = New-Object -comobject "Word.Application" -EA 0
	
	If(!$? -or $Script:Word -eq $Null)
	{
		Write-Warning "The Word object could not be created.  You may need to repair your Word installation."
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tThe Word object could not be created.  You may need to repair your Word installation.`n`n`t`tScript cannot continue.`n`n"
		Exit
	}

	Write-Verbose "$(Get-Date): Determine Word language value"
	If( ( validStateProp $Script:Word Language Value__ ) )
	{
		[int]$Script:WordLanguageValue = [int]$Script:Word.Language.Value__
	}
	Else
	{
		[int]$Script:WordLanguageValue = [int]$Script:Word.Language
	}

	If(!($Script:WordLanguageValue -gt -1))
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tUnable to determine the Word language value.`n`n`t`tScript cannot continue.`n`n"
		AbortScript
	}
	Write-Verbose "$(Get-Date): Word language value is $($Script:WordLanguageValue)"
	
	$Script:WordCultureCode = GetCulture $Script:WordLanguageValue
	
	SetWordHashTable $Script:WordCultureCode
	
	[int]$Script:WordVersion = [int]$Script:Word.Version
	If($Script:WordVersion -eq $wdWord2013)
	{
		$Script:WordProduct = "Word 2013"
	}
	ElseIf($Script:WordVersion -eq $wdWord2010)
	{
		$Script:WordProduct = "Word 2010"
	}
	ElseIf($Script:WordVersion -eq $wdWord2007)
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tMicrosoft Word 2007 is no longer supported.`n`n`t`tScript will end.`n`n"
		AbortScript
	}
	Else
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tYou are running an untested or unsupported version of Microsoft Word.`n`n`t`tScript will end.`n`n`t`tPlease send info on your version of Word to webster@carlwebster.com`n`n"
		AbortScript
	}

	#only validate CompanyName if the field is blank
	If([String]::IsNullOrEmpty($CoName))
	{
		Write-Verbose "$(Get-Date): Company name is blank.  Retrieve company name from registry."
		$TmpName = ValidateCompanyName
		
		If([String]::IsNullOrEmpty($TmpName))
		{
			Write-Warning "`n`n`t`tCompany Name is blank so Cover Page will not show a Company Name."
			Write-Warning "`n`t`tCheck HKCU:\Software\Microsoft\Office\Common\UserInfo for Company or CompanyName value."
			Write-Warning "`n`t`tYou may want to use the -CompanyName parameter if you need a Company Name on the cover page.`n`n"
		}
		Else
		{
			$Script:CoName = $TmpName
			Write-Verbose "$(Get-Date): Updated company name to $($Script:CoName)"
		}
	}

	If($Script:WordCultureCode -ne "en-")
	{
		Write-Verbose "$(Get-Date): Check Default Cover Page for $($WordCultureCode)"
		[bool]$CPChanged = $False
		Switch ($Script:WordCultureCode)
		{
			'ca-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Línia lateral"
						$CPChanged = $True
					}
				}

			'da-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Sidelinje"
						$CPChanged = $True
					}
				}

			'de-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Randlinie"
						$CPChanged = $True
					}
				}

			'es-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Línea lateral"
						$CPChanged = $True
					}
				}

			'fi-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Sivussa"
						$CPChanged = $True
					}
				}

			'fr-'	{
					If($CoverPage -eq "Sideline")
					{
						If($Script:WordVersion -eq $wdWord2013)
						{
							$CoverPage = "Lignes latérales"
							$CPChanged = $True
						}
						Else
						{
							$CoverPage = "Ligne latérale"
							$CPChanged = $True
						}
					}
				}

			'nb-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Sidelinje"
						$CPChanged = $True
					}
				}

			'nl-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Terzijde"
						$CPChanged = $True
					}
				}

			'pt-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Linha Lateral"
						$CPChanged = $True
					}
				}

			'sv-'	{
					If($CoverPage -eq "Sideline")
					{
						$CoverPage = "Sidlinje"
						$CPChanged = $True
					}
				}
		}

		If($CPChanged)
		{
			Write-Verbose "$(Get-Date): Changed Default Cover Page from Sideline to $($CoverPage)"
		}
	}

	Write-Verbose "$(Get-Date): Validate cover page $($CoverPage) for culture code $($Script:WordCultureCode)"
	[bool]$ValidCP = $False
	
	$ValidCP = ValidateCoverPage $Script:WordVersion $CoverPage $Script:WordCultureCode
	
	If(!$ValidCP)
	{
		$ErrorActionPreference = $SaveEAPreference
		Write-Verbose "$(Get-Date): Word language value $($Script:WordLanguageValue)"
		Write-Verbose "$(Get-Date): Culture code $($Script:WordCultureCode)"
		Write-Error "`n`n`t`tFor $($Script:WordProduct), $($CoverPage) is not a valid Cover Page option.`n`n`t`tScript cannot continue.`n`n"
		AbortScript
	}

	ShowScriptOptions

	$Script:Word.Visible = $False

	#http://jdhitsolutions.com/blog/2012/05/san-diego-2012-powershell-deep-dive-slides-and-demos/
	#using Jeff's Demo-WordReport.ps1 file for examples
	Write-Verbose "$(Get-Date): Load Word Templates"

	[bool]$Script:CoverPagesExist = $False
	[bool]$BuildingBlocksExist = $False

	$Script:Word.Templates.LoadBuildingBlocks()
	#word 2010/2013
	$BuildingBlocksCollection = $Script:Word.Templates | Where {$_.name -eq "Built-In Building Blocks.dotx"}

	Write-Verbose "$(Get-Date): Attempt to load cover page $($CoverPage)"
	$part = $Null

	$BuildingBlocksCollection | 
	ForEach{
		If ($_.BuildingBlockEntries.Item($CoverPage).Name -eq $CoverPage) 
		{
			$BuildingBlocks = $_
		}
	}        

	If($BuildingBlocks -ne $Null)
	{
		$BuildingBlocksExist = $True

		Try 
		{
			$part = $BuildingBlocks.BuildingBlockEntries.Item($CoverPage)
		}

		Catch
		{
			$part = $Null
		}

		If($part -ne $Null)
		{
			$Script:CoverPagesExist = $True
		}
	}

	If(!$Script:CoverPagesExist)
	{
		Write-Verbose "$(Get-Date): Cover Pages are not installed or the Cover Page $($CoverPage) does not exist."
		Write-Warning "Cover Pages are not installed or the Cover Page $($CoverPage) does not exist."
		Write-Warning "This report will not have a Cover Page."
	}

	Write-Verbose "$(Get-Date): Create empty word doc"
	$Script:Doc = $Script:Word.Documents.Add()
	If($Script:Doc -eq $Null)
	{
		Write-Verbose "$(Get-Date): "
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tAn empty Word document could not be created.`n`n`t`tScript cannot continue.`n`n"
		AbortScript
	}

	$Script:Selection = $Script:Word.Selection
	If($Script:Selection -eq $Null)
	{
		Write-Verbose "$(Get-Date): "
		$ErrorActionPreference = $SaveEAPreference
		Write-Error "`n`n`t`tAn unknown error happened selecting the entire Word document for default formatting options.`n`n`t`tScript cannot continue.`n`n"
		AbortScript
	}

	#set Default tab stops to 1/2 inch (this line is not from Jeff Hicks)
	#36 = .50"
	$Script:Word.ActiveDocument.DefaultTabStop = 36

	#Disable Spell and Grammar Check to resolve issue and improve performance (from Pat Coughlin)
	Write-Verbose "$(Get-Date): Disable grammar and spell checking"
	#bug reported 1-Apr-2014 by Tim Mangan
	#save current options first before turning them off
	$Script:CurrentGrammarOption = $Script:Word.Options.CheckGrammarAsYouType
	$Script:CurrentSpellingOption = $Script:Word.Options.CheckSpellingAsYouType
	$Script:Word.Options.CheckGrammarAsYouType = $False
	$Script:Word.Options.CheckSpellingAsYouType = $False

	If($BuildingBlocksExist)
	{
		#insert new page, getting ready for table of contents
		Write-Verbose "$(Get-Date): Insert new page, getting ready for table of contents"
		$part.Insert($Script:Selection.Range,$True) | Out-Null
		$Script:Selection.InsertNewPage()

		#table of contents
		Write-Verbose "$(Get-Date): Table of Contents - $($Script:MyHash.Word_TableOfContents)"
		$toc = $BuildingBlocks.BuildingBlockEntries.Item($Script:MyHash.Word_TableOfContents)
		If($toc -eq $Null)
		{
			Write-Verbose "$(Get-Date): "
			Write-Verbose "$(Get-Date): Table of Content - $($Script:MyHash.Word_TableOfContents) could not be retrieved."
			Write-Warning "This report will not have a Table of Contents."
		}
		Else
		{
			$toc.insert($Script:Selection.Range,$True) | Out-Null
		}
	}
	Else
	{
		Write-Verbose "$(Get-Date): Table of Contents are not installed."
		Write-Warning "Table of Contents are not installed so this report will not have a Table of Contents."
	}

	#set the footer
	Write-Verbose "$(Get-Date): Set the footer"
	[string]$footertext = "Report created by $username"

	#get the footer
	Write-Verbose "$(Get-Date): Get the footer and format font"
	$Script:Doc.ActiveWindow.ActivePane.view.SeekView = $wdSeekPrimaryFooter
	#get the footer and format font
	$footers = $Script:Doc.Sections.Last.Footers
	ForEach ($footer in $footers) 
	{
		If($footer.exists) 
		{
			$footer.range.Font.name = "Calibri"
			$footer.range.Font.size = 8
			$footer.range.Font.Italic = $True
			$footer.range.Font.Bold = $True
		}
	} #end ForEach
	Write-Verbose "$(Get-Date): Footer text"
	$Script:Selection.HeaderFooter.Range.Text = $footerText

	#add page numbering
	Write-Verbose "$(Get-Date): Add page numbering"
	$Script:Selection.HeaderFooter.PageNumbers.Add($wdAlignPageNumberRight) | Out-Null

	FindWordDocumentEnd
	Write-Verbose "$(Get-Date): End of Word setup" 
	Write-Verbose "$(Get-Date):"
	#end of Jeff Hicks 
}

Function UpdateDocumentProperties
{
	Param([string]$AbstractTitle, [string]$SubjectTitle)
	#Update document properties
	If($MSWORD -or $PDF)
	{
		If($Script:CoverPagesExist)
		{
			Write-Verbose "$(Get-Date): Set Cover Page Properties"
			_SetDocumentProperty $Script:Doc.BuiltInDocumentProperties "Company" $Script:CoName
			_SetDocumentProperty $Script:Doc.BuiltInDocumentProperties "Title" $Script:title
			_SetDocumentProperty $Script:Doc.BuiltInDocumentProperties "Author" $username
			_SetDocumentProperty $Script:Doc.BuiltInDocumentProperties "Subject" $SubjectTitle

			#Get the Coverpage XML part
			$cp = $Script:Doc.CustomXMLParts | Where {$_.NamespaceURI -match "coverPageProps$"}

			#get the abstract XML part
			$ab = $cp.documentelement.ChildNodes | Where {$_.basename -eq "Abstract"}

			#set the text
			If([String]::IsNullOrEmpty($Script:CoName))
			{
				[string]$abstract = $AbstractTitle
			}
			Else
			{
				[string]$abstract = "$($AbstractTitle) for $Script:CoName"
			}

			$ab.Text = $abstract

			$ab = $cp.documentelement.ChildNodes | Where {$_.basename -eq "PublishDate"}
			#set the text
			[string]$abstract = (Get-Date -Format d).ToString()
			$ab.Text = $abstract

			Write-Verbose "$(Get-Date): Update the Table of Contents"
			#update the Table of Contents
			$Script:Doc.TablesOfContents.item(1).Update()
			$cp = $Null
			$ab = $Null
			$abstract = $Null
		}
	}
}

Function SaveandCloseDocumentandShutdownWord
{
	#bug fix 1-Apr-2014
	#reset Grammar and Spelling options back to their original settings
	$Script:Word.Options.CheckGrammarAsYouType = $Script:CurrentGrammarOption
	$Script:Word.Options.CheckSpellingAsYouType = $Script:CurrentSpellingOption

	Write-Verbose "$(Get-Date): Save and Close document and Shutdown Word"
	If($Script:WordVersion -eq $wdWord2010)
	{
		#the $saveFormat below passes StrictMode 2
		#I found this at the following two links
		#http://blogs.technet.com/b/bshukla/archive/2011/09/27/3347395.aspx
		#http://msdn.microsoft.com/en-us/library/microsoft.office.interop.word.wdsaveformat(v=office.14).aspx
		If($PDF)
		{
			Write-Verbose "$(Get-Date): Saving as DOCX file first before saving to PDF"
		}
		Else
		{
			Write-Verbose "$(Get-Date): Saving DOCX file"
		}
		If($AddDateTime)
		{
			$Script:FileName1 += "_$(Get-Date -f yyyy-MM-dd_HHmm).docx"
			If($PDF)
			{
				$Script:FileName2 += "_$(Get-Date -f yyyy-MM-dd_HHmm).pdf"
			}
		}
		Write-Verbose "$(Get-Date): Running Word 2010 and detected operating system $($RunningOS)"
		$saveFormat = [Enum]::Parse([Microsoft.Office.Interop.Word.WdSaveFormat], "wdFormatDocumentDefault")
		$Script:Doc.SaveAs([REF]$Script:FileName1, [ref]$SaveFormat)
		If($PDF)
		{
			Write-Verbose "$(Get-Date): Now saving as PDF"
			$saveFormat = [Enum]::Parse([Microsoft.Office.Interop.Word.WdSaveFormat], "wdFormatPDF")
			$Script:Doc.SaveAs([REF]$Script:FileName2, [ref]$saveFormat)
		}
	}
	ElseIf($Script:WordVersion -eq $wdWord2013)
	{
		If($PDF)
		{
			Write-Verbose "$(Get-Date): Saving as DOCX file first before saving to PDF"
		}
		Else
		{
			Write-Verbose "$(Get-Date): Saving DOCX file"
		}
		If($AddDateTime)
		{
			$Script:FileName1 += "_$(Get-Date -f yyyy-MM-dd_HHmm).docx"
			If($PDF)
			{
				$Script:FileName2 += "_$(Get-Date -f yyyy-MM-dd_HHmm).pdf"
			}
		}
		Write-Verbose "$(Get-Date): Running Word 2013 and detected operating system $($RunningOS)"
		$Script:Doc.SaveAs2([REF]$Script:FileName1, [ref]$wdFormatDocumentDefault)
		If($PDF)
		{
			Write-Verbose "$(Get-Date): Now saving as PDF"
			$Script:Doc.SaveAs([REF]$Script:FileName2, [ref]$wdFormatPDF)
		}
	}

	Write-Verbose "$(Get-Date): Closing Word"
	$Script:Doc.Close()
	$Script:Word.Quit()
	If($PDF)
	{
		Write-Verbose "$(Get-Date): Deleting $($Script:FileName1) since only $($Script:FileName2) is needed"
		Remove-Item $Script:FileName1
	}
	Write-Verbose "$(Get-Date): System Cleanup"
	[System.Runtime.Interopservices.Marshal]::ReleaseComObject($Script:Word) | Out-Null
	If(Test-Path variable:global:word)
	{
		Remove-Variable -Name word -Scope Global
	}
	$SaveFormat = $Null
	[gc]::collect() 
	[gc]::WaitForPendingFinalizers()
}

Function SaveandCloseTextDocument
{
	If($AddDateTime)
	{
		$Script:FileName1 += "_$(Get-Date -f yyyy-MM-dd_HHmm).txt"
	}

	Write-Output $Global:Output | Out-File $Script:Filename1
}

Function SaveandCloseHTMLDocument
{
	If($AddDateTime)
	{
		$Script:FileName1 += "_$(Get-Date -f yyyy-MM-dd_HHmm).html"
	}
}

Function SetFileName1andFileName2
{
	Param([string]$OutputFileName)
	$pwdpath = $pwd.Path

	# if using the GUI, get the output file and directory from there
	If($GUI -eq $True) 
	{
		$pwdpath = $OutputDir
		$OutputFileName = $OutputFile
		Write-Verbose "$(Get-Date): Using output file from GUI:"
		Write-Verbose "$(Get-Date): Output path: $($OutputDir)"
		Write-Verbose "$(Get-Date): Output file: $($OutputFile)"
	}
	Else
	{
		# if output dir or filename was specified on the command line, use that
		If($OutputDir -ne "") { $pwdpath = $OutputDir }
		If($OutputFile -ne "") { $OutputFileName = $OutputFile }
	}
	
	If($pwdpath.EndsWith("\"))
	{
		#remove the trailing \
		$pwdpath = $pwdpath.SubString(0, ($pwdpath.Length - 1))
	}

	#set $filename1 and $filename2 with no file extension
	If($AddDateTime)
	{
		[string]$Script:FileName1 = "$($pwdpath)\$($OutputFileName)"
		If($PDF)
		{
			[string]$Script:FileName2 = "$($pwdpath)\$($OutputFileName)"
		}
	}

	If($MSWord -or $PDF)
	{
		CheckWordPreReq

		If(!$AddDateTime)
		{
			[string]$Script:FileName1 = "$($pwdpath)\$($OutputFileName).docx"
			If($PDF)
			{
				[string]$Script:FileName2 = "$($pwdpath)\$($OutputFileName).pdf"
			}
		}

		SetupWord
	}
	ElseIf($Text)
	{
		If(!$AddDateTime)
		{
			[string]$Script:FileName1 = "$($pwdpath)\$($OutputFileName).txt"
		}
	}
	ElseIf($HTML)
	{
		If(!$AddDateTime)
		{
			[string]$Script:FileName1 = "$($pwdpath)\$($OutputFileName).html"
		}
	}
}

#***********************************************************************************************************
# WriteHTMLLine
#***********************************************************************************************************

<#
.Synopsis
	Writes a line of output for HTML output
.DESCRIPTION
	This function formats an HTML line
.USAGE
	WriteHTMLLine <Style> <Tabs> <Name> <Value> <Font Name> <Font Size> <Options>

	0 for Font Size denotes using the default font size of 2 or 10 point

.EXAMPLE
	WriteHTMLLine 0 0 ""

	Writes a blank line with no style or tab stops, obviously none needed.

.EXAMPLE
	WriteHTMLLine 0 1 "This is a regular line of text indented 1 tab stops"

	Writes a line with 1 tab stop.

.EXAMPLE
	WriteHTMLLine 0 0 "This is a regular line of text in the default font in italics" "" $null 0 $htmlitalics

	Writes a line omitting font and font size and setting the italics attribute

.EXAMPLE
	WriteHTMLLine 0 0 "This is a regular line of text in the default font in bold" "" $null 0 $htmlbold

	Writes a line omitting font and font size and setting the bold attribute

.EXAMPLE
	WriteHTMLLine 0 0 "This is a regular line of text in the default font in bold italics" "" $null 0 ($htmlbold -bor $htmlitalics)

	Writes a line omitting font and font size and setting both italics and bold options

.EXAMPLE	
	WriteHTMLLine 0 0 "This is a regular line of text in the default font in 10 point" "" $null 2  # 10 point font

	Writes a line using 10 point font

.EXAMPLE
	WriteHTMLLine 0 0 "This is a regular line of text in Courier New font" "" "Courier New" 0 

	Writes a line using Courier New Font and 0 font point size (default = 2 if set to 0)

.EXAMPLE	
	WriteHTMLLine 0 0 "This is a regular line of RED text indented 0 tab stops with the computer name as data in 10 point Courier New bold italics: " $env:computername "Courier New" 2 ($htmlbold -bor $htmlred -bor $htmlitalics)

	Writes a line using Courier New Font with first and second string values to be used, also uses 10 point font with bold, italics and red color options set.

.NOTES

	Font Size - Unlike word, there is a limited set of font sizes that can be used in HTML.  They are:
		0 - default which actually gives it a 2 or 10 point.
		1 - 7.5 point font size
		2 - 10 point
		3 - 13.5 point
		4 - 15 point
		5 - 18 point
		6 - 24 point
		7 - 36 point
	Any number larger than 7 defaults to 7

	Style - Refers to the headers that are used with output and resemble the headers in word, 
	HTML supports headers h1-h6 and h1-h4 are more commonly used.  Unlike word, H1 will not 
	give you a blue colored font, you will have to set that yourself.

	Colors and Bold/Italics Flags are:

		htmlbold       
		htmlitalics    
		htmlred        
		htmlcyan        
		htmlblue       
		htmldarkblue   
		htmllightblue   
		htmlpurple      
		htmlyellow      
		htmllime       
		htmlmagenta     
		htmlwhite       
		htmlsilver      
		htmlgray       
		htmlolive       
		htmlorange      
		htmlmaroon      
		htmlgreen       
		htmlblack       
#>

Function WriteHTMLLine
#Function created by Ken Avram
#Function created to make output to HTML easy in this script
{
	Param([int]$style=0, 
	[int]$tabs = 0, 
	[string]$name = '', 
	[string]$value = '', 
	[string]$fontName="Calibri",
	[int]$fontSize=1,
	[int]$options=$htmlblack)


	#Build output style
	[string]$output = ""

	If([String]::IsNullOrEmpty($Name))	
	{
		$HTMLBody = "<p></p>"
	}
	Else
	{
		$color = CheckHTMLColor $options

		#build # of tabs

		While($tabs -gt 0)
		{ 
			$output += "&nbsp;&nbsp;&nbsp;&nbsp;"; $tabs--; 
		}

		$HTMLFontName = $fontName		

		$HTMLBody = ""

		If($options -band $htmlitalics) 
		{
			$HTMLBody += "<i>"
		} 

		If($options -band $htmlbold) 
		{
			$HTMLBody += "<b>"
		} 

		#output the rest of the parameters.
		$output += $name + $value

		$HTMLBody += "<br><font face='" + $HTMLFontName + "' " + "color='" + $color + "' size='"  + $fontsize + "'>"
		
		Switch ($style)
		{
			1 {$HTMLStyle = "<h1>"}
			2 {$HTMLStyle = "<h2>"}
			3 {$HTMLStyle = "<h3>"}
			4 {$HTMLStyle = "<h4>"}
			Default {$HTMLStyle = ""}
		}

		$HTMLBody += $HTMLStyle + $output

		Switch ($style)
		{
			1 {$HTMLStyle = "</h1>"}
			2 {$HTMLStyle = "</h2>"}
			3 {$HTMLStyle = "</h3>"}
			4 {$HTMLStyle = "</h4>"}
			Default {$HTMLStyle = ""}
		}

		$HTMLBody += $HTMLStyle +  "</font>"

		If($options -band $htmlitalics) 
		{
			$HTMLBody += "</i>"
		} 

		If($options -band $htmlbold) 
		{
			$HTMLBody += "</b>"
		} 
	}
	$HTMLBody += <br />

	out-file -FilePath $Script:FileName1 -Append -InputObject $HTMLBody 4>$Null
}
#endregion

#region HTML table functions
#***********************************************************************************************************
# AddHTMLTable - Called from FormatHTMLTable function
#***********************************************************************************************************
Function AddHTMLTable
{
	Param([string]$fontName="Calibri",
	[int]$fontSize=2,
	[int]$colCount=0,
	[int]$rowCount=0,
	[object[]]$rowInfo=@())

	For($rowidx = $RowIndex;$rowidx -le $rowCount;$rowidx++)
	{
		$rd = @($rowInfo[$rowidx - 2])
		$htmlbody = $htmlbody + "<tr>"
		For($columnIndex = 0; $columnIndex -lt $colCount; $columnindex+=2)
		{
			$fontitalics = $False
			$fontbold = $false
			$tmp = CheckHTMLColor $rd[$columnIndex+1]

			$htmlbody += "<td bgcolor='" + $tmp + "'><font face='" + $fontname + "' size='" + $fontsize + "'>"
			If($rd[$columnIndex+1] -band $htmlbold)
			{
				$htmlbody += "<b>"
			}
			If($rd[$columnIndex+1] -band $htmlitalics)
			{
				$htmlbody += "<i>"
			}
			If($rd[$columnIndex] -ne $null)
			{
				$cell = $rd[$columnIndex].tostring()
				If($cell -eq " " -or $cell.length -eq 0)
				{
					$htmlbody += "&nbsp;&nbsp;&nbsp;"
				}
				Else
				{
					For($i=0;$i -lt $cell.length;$i++)
					{
						If($cell[$i] -eq " ")
						{
							$htmlbody += "&nbsp;"
						}
						If($cell[$i] -ne " ")
						{
							Break
						}
					}
					$htmlbody += $cell
				}
			}
			Else
			{
				$htmlbody += "&nbsp;&nbsp;&nbsp;"
			}
			If($rd[$columnIndex+1] -band $htmlbold)
			{
				$htmlbody += "</b>"
			}
			If($rd[$columnIndex+1] -band $htmlitalics)
			{
				$htmlbody += "</i>"
			}
			$htmlbody += "</font></td>"
		}
		$htmlbody += "</tr>"
	}
	out-file -FilePath $Script:FileName1 -Append -InputObject $HTMLBody 4>$Null 
}

#***********************************************************************************************************
# FormatHTMLTable 
#***********************************************************************************************************

<#
.Synopsis
	Format table for HTML output document
.DESCRIPTION
	This function formats a table for HTML from an array of strings
.PARAMETER noBorder
	If set to $true, a table will be generated without a border (border='0')
.PARAMETER noHeadCols
	This parameter should be used when generating tables without column headers
	Set this parameter equal to the number of columns in the table
.PARAMETER rowArray
	This parameter contains the row data array for the table
.PARAMETER columnArray
	This parameter contains column header data for the table
.USAGE
	FormatHTMLTable <Table Header> <Table Format> <Font Name> <Font Size>
.EXAMPLE
	FormatHTMLTable "Table Heading" "auto" "Calibri" 3

	This example formats a table and writes it out into an html file.  All of the parameters are optional
	defaults are used if not supplied.

	for <Table format>, the default is auto which will autofit the text into the columns and adjust to the longest text in that column.  You can also use percentage i.e. 25%
	which will take only 25% of the line and will auto word wrap the text to the next line in the column.  Also, instead of using a percentage, you can use pixels i.e. 400px.

	FormatHTMLTable "Table Heading" "auto"
	FormatHTMLTable "Table Heading" "25%
	FormatHTMLTable "Table Heading" "400px"

.NOTES
	In order to use the formatted table it first has to be loaded with data.  Examples below will show how to load the table:

	First, initialize the table array

	$rowdata = @()

	Then Load the array.  If you are using column headers then load those into the column headers array, otherwise the first line of the table goes into the column headers array
	and the second and subsequent lines go into the $rowdata table as shown below:

	$columnHeaders = @('Display Name',($htmlsilver -bor $htmlbold),'Status',($htmlsilver -bor $htmlbold),'Startup Type',($htmlsilver -bor $htmlbold))

	The first column is the actual name to display, the second are the attributes of the column i.e. color anded with bold or italics.  For the anding, parens are required or it will
	not format correctly.

	This is following by adding rowdata as shown below.  As more columns are added the columns will auto adjust to fit the size of the page.

	$rowdata = @()
	$columnHeaders = @("User Name",($htmlsilver -bor $htmlbold),$UserName,$htmlwhite)
	$rowdata += @(,('Save as PDF',($htmlsilver -bor $htmlbold),$PDF.ToString(),$htmlwhite))
	$rowdata += @(,('Save as TEXT',($htmlsilver -bor $htmlbold),$TEXT.ToString(),$htmlwhite))
	$rowdata += @(,('Save as WORD',($htmlsilver -bor $htmlbold),$MSWORD.ToString(),$htmlwhite))
	$rowdata += @(,('Save as HTML',($htmlsilver -bor $htmlbold),$HTML.ToString(),$htmlwhite))
	$rowdata += @(,('Add DateTime',($htmlsilver -bor $htmlbold),$AddDateTime.ToString(),$htmlwhite))
	$rowdata += @(,('Hardware Inventory',($htmlsilver -bor $htmlbold),$Hardware.ToString(),$htmlwhite))
	$rowdata += @(,('Computer Name',($htmlsilver -bor $htmlbold),$ComputerName,$htmlwhite))
	$rowdata += @(,('Filename1',($htmlsilver -bor $htmlbold),$Script:FileName1,$htmlwhite))
	$rowdata += @(,('OS Detected',($htmlsilver -bor $htmlbold),$RunningOS,$htmlwhite))
	$rowdata += @(,('PSUICulture',($htmlsilver -bor $htmlbold),$PSCulture,$htmlwhite))
	$rowdata += @(,('PoSH version',($htmlsilver -bor $htmlbold),$Host.Version.ToString(),$htmlwhite))
	FormatHTMLTable "Example of Horizontal AutoFitContents HTML Table"

	Colors and Bold/Italics Flags are shown below:

		htmlbold       
		htmlitalics    
		htmlred        
		htmlcyan        
		htmlblue       
		htmldarkblue   
		htmllightblue   
		htmlpurple      
		htmlyellow      
		htmllime       
		htmlmagenta     
		htmlwhite       
		htmlsilver      
		htmlgray       
		htmlolive       
		htmlorange      
		htmlmaroon      
		htmlgreen       
		htmlblack     

#>

Function FormatHTMLTable
{
	Param([string]$tableheader,
	[string]$tablewidth="auto",
	[string]$fontName="Calibri",
	[int]$fontSize=2,
	[switch]$noBorder=$false,
	[int]$noHeadCols=1,
	[object[]]$rowArray=@(),
	[object[]]$columnArray=@())

	$HTMLBody = "<b><font face='" + $fontname + "' size='" + ($fontsize + 1) + "'>" + $tableheader + "</font></b>"

	If($columnArray.Length -eq 0)
	{
		$NumCols = $noHeadCols + 1
	}  # means we have no column headers, just a table
	Else
	{
		$NumCols = $columnArray.Length
	}  # need to add one for the color attrib

	If($rowArray -ne $null)
	{
		$NumRows = $rowArray.length + 1
	}
	Else
	{
		$NumRows = 1
	}

	If($noBorder)
	{
		$htmlbody += "<table border='0' width='" + $tablewidth + "'>"
	}
	Else
	{
		$htmlbody += "<table border='1' width='" + $tablewidth + "'>"
	}

	If(!($columnArray.Length -eq 0))
	{
		$htmlbody += "<tr>"

		For($columnIndex = 0; $columnIndex -lt $NumCols; $columnindex+=2)
		{
			$tmp = CheckHTMLColor $columnArray[$columnIndex+1]

			$htmlbody += "<td bgcolor='" + $tmp + "'><font face='" + $fontname + "' size='" + $fontsize + "'>"

			If($columnArray[$columnIndex+1] -band $htmlbold)
			{
				$htmlbody += "<b>"
			}
			If($columnArray[$columnIndex+1] -band $htmlitalics)
			{
				$htmlbody += "<i>"
			}
			If($columnArray[$columnIndex] -ne $null)
			{
				If($columnArray[$columnIndex] -eq " " -or $columnArray[$columnIndex].length -eq 0)
				{
					$htmlbody += "&nbsp;&nbsp;&nbsp;"
				}
				Else
				{
					$found = $false
					For($i=0;$i -lt $columnArray[$columnIndex].length;$i+=2)
					{
						If($columnArray[$columnIndex][$i] -eq " ")
						{
							$htmlbody += "&nbsp;"
						}
						If($columnArray[$columnIndex][$i] -ne " ")
						{
							Break
						}
					}
					$htmlbody += $columnArray[$columnIndex]
				}
			}
			Else
			{
				$htmlbody += "&nbsp;&nbsp;&nbsp;"
			}
			If($columnArray[$columnIndex+1] -band $htmlbold)
			{
				$htmlbody += "</b>"
			}
			If($columnArray[$columnIndex+1] -band $htmlitalics)
			{
				$htmlbody += "</i>"
			}
			$htmlbody += "</font></td>"
		}

		$htmlbody += "</tr>"
	}
	$rowindex = 2
	If($rowArray -ne $null)
	{
		AddHTMLTable $fontName $fontSize -colCount $numCols -rowCount $NumRows -rowInfo $rowArray
		$rowArray = @()
		$htmlbody = "</table>"
	}
	Else
	{
		$HTMLBody += "</table>"
	}	

	out-file -FilePath $Script:FileName1 -Append -InputObject $HTMLBody 4>$Null 
	$columnArray = @()
}
#endregion

#region other HTML functions
#***********************************************************************************************************
# CheckHTMLColor - Called from AddHTMLTable WriteHTMLLine and FormatHTMLTable
#***********************************************************************************************************
Function CheckHTMLColor
{
	Param($hash)

	If($hash -band $htmlwhite)
	{
		Return $htmlwhitemask
	}
	If($hash -band $htmlred)
	{
		Return $htmlredmask
	}
	If($hash -band $htmlcyan)
	{
		Return $htmlcyanmask
	}
	If($hash -band $htmlblue)
	{
		Return $htmlbluemask
	}
	If($hash -band $htmldarkblue)
	{
		Return $htmldarkbluemask
	}
	If($hash -band $htmllightblue)
	{
		Return $htmllightbluemask
	}
	If($hash -band $htmlpurple)
	{
		Return $htmlpurplemask
	}
	If($hash -band $htmlyellow)
	{
		Return $htmlyellowmask
	}
	If($hash -band $htmllime)
	{
		Return $htmllimemask
	}
	If($hash -band $htmlmagenta)
	{
		Return $htmlmagentamask
	}
	If($hash -band $htmlsilver)
	{
		Return $htmlsilvermask
	}
	If($hash -band $htmlgray)
	{
		Return $htmlgraymask
	}
	If($hash -band $htmlblack)
	{
		Return $htmlblackmask
	}
	If($hash -band $htmlorange)
	{
		Return $htmlorangemask
	}
	If($hash -band $htmlmaroon)
	{
		Return $htmlmaroonmask
	}
	If($hash -band $htmlgreen)
	{
		Return $htmlgreenmask
	}
	If($hash -band $htmlolive)
	{
		Return $htmlolivemask
	}
}

Function SetupHTML
{
	Write-Verbose "$(Get-Date): Setting up HTML"
    If($AddDateTime)
    {
		$Script:FileName1 += "_$(Get-Date -f yyyy-MM-dd_HHmm).html"
    }

    $htmlhead = "<html><head><meta http-equiv='Content-Language' content='da'><title>" + $Script:Title + "</title></head><body>"
    #echo $htmlhead > $FileName1
	out-file -FilePath $Script:FileName1 -Force -InputObject $HTMLHead 4>$Null
}
#endregion

#~~< post-GUI script processing begins here >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

$script:startTime = Get-Date

If($TEXT)
{
	$global:output = ""
}

[int] $Chapter  = 0
[int] $Chapters = 7

###The function SetFileName1andFileName2 needs your script output filename - ignored when using GUI!
SetFileName1andFileName2 "StoreFront"

###change title for your report - should be put into GUI
[string]$Script:Title = "StoreFront Configuration"

# open StoreFront XML file
Write-Verbose "$(Get-Date): Opening input file $($InputFile)"
$xmlDoc = [xml](Get-Content $InputFile)

# do we have hardware and/or software info
if ($xmlDoc.StoreFront.Hardware -ne $Null) {++$Chapters}
if ($xmlDoc.StoreFront.Software -ne $Null) {++$Chapters}

$hostInfo = $xmlDoc.StoreFront.HostInfo

$serverGroup = $xmlDoc.StoreFront.ServerGroup
$baseURL = $serverGroup.baseURL
$members = $serverGroup.Members
$memberCount = $serverGroup.MemberCount

If ($memberCount -gt 1) 
{
	$config = $serverGroup.LastSource
}
Write-Verbose "$(Get-Date): Start writing report data"

If($MSWORD -or $PDF)
{
	#insert a new page to start the report
	$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Host Information"
	WriteWordLine 1 0 "Host Information"
	WriteWordLine 0 0 ""
	[System.Collections.Hashtable[]] $hostDetails = @()
	$hostDetails += @{ Data = "Host Server"; Value = $hostInfo.ServerName; }
	$hostDetails += @{ Data = "StoreFront Version"; Value = $hostInfo.SFVersion; }
	$hostDetails += @{ Data = "As Of"; Value = $hostInfo.AsOf; }
	$Table = AddWordTable -Hashtable $hostDetails -Columns Data,Value -List -AutoFit $wdAutoFitFixed #-AutoFit $wdAutoFitContent;
	SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Server Group"
	WriteWordLine 1 0 "Server Group"
	WriteWordLine 0 0 ""
	WriteWordLine 2 0 "Group Details"
	[System.Collections.Hashtable[]] $groupDetails = @()
	$groupDetails += @{ Data = "Base URL"; Value = $baseURL; }
	$groupDetails += @{ Data = "Number of servers"; Value = $memberCount; }
	If ($memberCount -gt 1)
	{
		#Write-Verbose "$(Get-Date): $($memberCount) server(s) in group"
		$groupDetails += @{ Data = "Configuration"; Value = "Last propagated from $($config.ToLower())"; }
	}

	$Table = AddWordTable -Hashtable $groupDetails -Columns Data,Value -List -AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent;
	SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$groupDetails = $Null
	
	If ($memberCount -gt 1)
	{	
		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Server Details"
		[System.Collections.Hashtable[]] $serverDetails = @();
		foreach ($mem in $members.member)
		{
			Write-Verbose "$(Get-Date):   Server: $($mem.name) "
			$memName = $mem.name.ToUpper();
			if ($memName -eq $config.ToUpper())
			{
				$sync = "Propagated changes at $($mem.lastSync)"
			} Else {
				$sync = "Synchronized changes with $($config.ToUpper()) at $($mem.lastSync)"
			}
			if ($memName -eq $hostInfo.ServerName.ToUpper()) { $memName += " (this server)" }
			$serverDetails += @{ memberName	= $memName; lastSync = $sync; }
		}
		
		$Table = AddWordTable -Hashtable $serverDetails `
		-Columns memberName, lastSync `
		-Headers "Server Name", "Synchronization Status" `
		-AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent
		
		SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
		
        FindWordDocumentEnd
        WriteWordLine 0 0 " "
		$Table = $Null
		$serverDetails = $Null
	}
	
	$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Authentication Service"
	WriteWordLine 1 0 "Authentication"
	WriteWordLine 0 0 ""
	WriteWordLine 2 0 "Authentication Methods"

	$authentication = $xmldoc.StoreFront.Authentication
	$methods = @($authentication.Methods.Method)
	[System.Collections.Hashtable[]] $authMethods = @();
	foreach ($method in $methods)
	{
		$methName = $method.name;
		$enabled = $method.enabled;
		$authMethods += @{ methName	= $methName; enabled = $enabled; }
	}
	
	$Table = AddWordTable -Hashtable $authMethods `
	-Columns methName, enabled `
	-Headers "Authentication Method", "Enabled" `
	-AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent
	
	SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$authMethods = $Null	

	WriteWordLine 0 0 ""	
	WriteWordLine 2 0 "Authentication Service"
	WriteWordLine 0 0 " "

	WriteWordLine 3 0 "Overview"
	[System.Collections.Hashtable[]] $authService = @()
	$authService += @{ Data = "Token validation service"; Value = $authentication.tokenURL; }
	$authService += @{ Data = "Number of enabled methods"; Value = $authentication.EnabledMethods; }
	
	# to highlight SSL expiration
	[System.Collections.Hashtable[]] $HighlightedCells = @();
	$sslExpiration = ([datetime] $authentication.SSLExpiration).ToString('MM/dd/yyyy')
	If([int] $authentication.daysUntilExpiration -lt 0)
	{
		$authStatus = "Certificate has expired ($($sslExpiration))."; 
		$HighlightedCells += @{ Row = 3; Column = 2; }
	}
	ElseIf([int] $authentication.daysUntilExpiration -lt 30)
	{
		$authStatus = "Certificate is about to expire ($($sslExpiration))."; 
		$HighlightedCells += @{ Row = 3; Column = 2; }
	}
	ElseIf($authentication.status.Contains("HTTPS"))
	{
		$authStatus = "Service using HTTPS."; 
	}
	Else
	{
		$authStatus = "Service using HTTP."; 
		$HighlightedCells += @{ Row = 3; Column = 2; }
	}	
	
	$authService += @{ Data = "Status"; Value = $authStatus; }
	$Table = AddWordTable -Hashtable $authService -Columns Data,Value -List -AutoFit $wdAutoFitContent; # $wdAutoFitFixed 
	SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	
	if ($HighlightedCells.Length -gt 0) 
	{
		SetWordCellFormat -Coordinates $HighlightedCells -Table $Table -Bold -Color 16777215 -BackgroundColor $wdColorRed -Solid;
	}
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$authService = $Null
	
	WriteWordLine 3 0 "Trusted Domains"
	$trustedDomains = $authentication.TrustedDomains
	[System.Collections.Hashtable[]] $domains = @()
	$domains += @{ Data = "Allow users to log on from"; Value = $trustedDomains.AllowLogOn; }

	$domainList = @($trustedDomains.Domain)
	$strItems = ""
	foreach($item in $domainList) {if($strItems -eq ""){$strItems += "$($item.name)"} else {$strItems += "`v`t$($item.name)"} }	
	$domains += @{ Data = "Trusted domains"; Value = $strItems; }

	$domains += @{ Data = "Default domain"; Value = $trustedDomains.DefaultDomain; }
	$showDomains = $trustedDomains.ShowDomains
	If($showDomains -ne $Null)
	{
		$domains += @{ Data = "Show domains list in logon page:"; Value = $showDomains; }
	}
	$Table = AddWordTable -Hashtable $domains -Columns Data,Value -List -AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent;
	SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$domains = $Null

	WriteWordLine 3 0 "Passwords"
	[System.Collections.Hashtable[]] $passwords = @()
	$passwords += @{ Data = "Allow users to change passwords"; Value = $authentication.changePW; }
	$Table = AddWordTable -Hashtable $passwords -Columns Data,Value -List -AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent;
	SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$passwords = $Null	
	
	$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Stores"
	WriteWordLine 1 0 "Stores"
	WriteWordLine 0 0 ""
	$stores = @($xmldoc.StoreFront.Stores.Store)
	[System.Collections.Hashtable[]] $storesTable = @();
	
	## first we do a store summary
	foreach ($store in $stores)
	{
		$storeName = $store.Name;
		$authenticated = $store.Authenticated;
		$locked = $store.Locked;
		$advertised = $store.Advertised;
		$storeURL = $store.storeURL;
		$access = $store.Access;
		$storesTable += @{ storeName = $storeName; authenticated = $authenticated; locked = $locked; advertised = $advertised; }
	}
	
	$Table = AddWordTable -Hashtable $storesTable `
	-Columns storeName, authenticated, advertised, locked `
	-Headers "Name", "Authenticated", "Advertised", "Locked" `
	-AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent
	SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$storesTable = $Null	
		
	## now we display details for each store
	foreach ($store in $stores)
	{
		$storeName = $store.Name;
		Write-Verbose "$(Get-Date):   Store: $storeName "
		$authenticated = $store.Authenticated;
		$locked = $store.Locked;
		$advertised = $store.Advertised;
		$storeURL = $store.storeURL;
		$access = $store.Access;

		WriteWordLine 2 1 "Store: $($storeName)"
		WriteWordLine 0 0 ""
		
		[System.Collections.Hashtable[]] $storeTable = @();
		$storeTable += @{ Data = "Authenticated"; Value = $authenticated; }
		$storeTable += @{ Data = "Advertised"; Value = $advertised; }
		$storeTable += @{ Data = "Locked"; Value = $locked; }
		$storeTable += @{ Data = "URL"; Value = $storeURL; }
		$storeTable += @{ Data = "Access"; Value = $access; }
		$Table = AddWordTable -Hashtable $storeTable -Columns Data,Value -List -AutoFit $wdAutoFitContent; # -AutoFit $wdAutoFitFixed
		SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$storeTable = $Null	

		if(!($store.ResourceFilters -eq $Null))
		{		
			## Resource Filtering
			$includedTypes = @($store.ResourceFilters.IncludedTypes.includedType);
			$includedKeywords = @($store.ResourceFilters.IncludedKeywords.includedKeyword);
			$excludedKeywords = @($store.ResourceFilters.ExcludedKeywords.excludedKeyword);
			WriteWordLine 3 1 "Resource Filtering"
			WriteWordLine 0 0 ""
			$Table = AddWordTable `
			-Hashtable @{ types = $includedTypes -join "`v"; included = $includedKeywords -join "`v`t"; excluded = $excludedKeywords -join "`v`t`t";} `
			-Columns types, included, excluded `
			-Headers "Included types", "Included Keywords", "Excluded Keywords" `
			-AutoFit $wdAutoFitFixed 
			SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
			$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
			$Table = $Null
			FindWordDocumentEnd
			WriteWordLine 0 0 " "		
		}
		
		
		## delivery controller summary for the store
		WriteWordLine 3 1 "Delivery controllers"
		WriteWordLine 0 0 ""

		$farms = @($store.Farms.Farm)
		[System.Collections.Hashtable[]] $farmTable = @();
		foreach ($farm in $farms)
		{
			$farmTable += @{ farmName = $farm.FarmName; farmType = $farm.FarmType; }
		}
		$Table = AddWordTable -Hashtable $farmTable -Columns farmName, farmType -Headers "Name", "Type" `
			-AutoFit $wdAutoFitFixed # -AutoFit $wdAutoFitContent
		SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$farmTable = $Null	

		## delivery controller detail for the store
		foreach ($farm in $farms)
		{		
			WriteWordLine 3 1 "Delivery controller: $($farm.farmName)"
			WriteWordLine 0 0 ""
			[System.Collections.Hashtable[]] $dcTable = @();
			$dcTable += @{ Data = "Type"; Value = $farm.FarmType; }
			$servers = @($farm.Servers.Server)
			$serverLabel = "Servers"
			foreach ($server in $servers)
			{
				$dcTable += @{ Data = $serverLabel; Value = $server.name; }
				$serverLabel = ""
			}
			If($farm.farmType -eq "XenDesktop" -or $farm.farmType -eq "XenApp")
			{
				$dcTable += @{ Data = "Transport type"; Value = $farm.TransportType; }
				$dcTable += @{ Data = "Port"; Value = $farm.XMLPort; }
				$dcTable += @{ Data = "Load balanced"; Value = $farm.LoadBalance; }
			} 
			Elseif($farm.farmType -eq "AppController")
						{
				$dcTable += @{ Data = "Port"; Value = $farm.XMLPort; }
			} 
			$Table = AddWordTable -Hashtable $dcTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
			#SetWordCellFormat -Collection $Table.Columns.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
			$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
			FindWordDocumentEnd
			WriteWordLine 0 0 " "
			$Table = $Null
			$dcTable = $Null	
		}
		WriteWordLine 3 1 "Citrix Online Integration"
		WriteWordLine 0 0 ""
		[System.Collections.Hashtable[]] $colTable = @();
		$colTable += @{ Data = "GoToMeeting"; Value = $store.CitrixOnline.GoToMeeting; }
		$colTable += @{ Data = "GoToWebinar"; Value = $store.CitrixOnline.GoToWebinar; }
		$colTable += @{ Data = "GoToTraining"; Value = $store.CitrixOnline.GoToTraining; }
		$Table = AddWordTable -Hashtable $colTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$colTable = $Null	

		WriteWordLine 3 1 "Remote Access"
		WriteWordLine 0 0 ""
		$remoteAccess = $store.RemoteAccess
		[System.Collections.Hashtable[]] $colTable = @();
		$colTable += @{ Data = "Remote access"; Value = $remoteAccess.RemoteType; }
		if ($remoteAccess.RemoteType -ne "None") 
		{
			$appliances = @($remoteAccess.RemoteGW)
			$strItems = ""
			foreach($item in $appliances) {if($strItems -eq ""){$strItems += "$($item)"} else {$strItems += "`v`t$($item)"} }	
			$colTable += @{ Data = "NetScaler Gateway appliances"; Value = $strItems; }
			$colTable += @{ Data = "Default appliance"; Value = $remoteAccess.DefaultGW; }
		}
		$Table = AddWordTable -Hashtable $colTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$colTable = $Null			
		
	}
	
	$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Receiver for Web"
	WriteWordLine 1 0 "Receiver for Web"
	WriteWordLine 0 0 ""
	$receivers = @($xmlDoc.StoreFront.ReceiverForWeb.Receiver)
	
	## summary
	[System.Collections.Hashtable[]] $receiverSummary = @();
	foreach ($receiver in $receivers)
	{
		$receiverName = $receiver.Name;
		#$storename = $receiver.Store;
		$webURL = $receiver.webURL;
		$authenticated = $receiver.Authenticated;
		$receiverSummary += @{ receiverName = $receiverName; webURL = $webURL; authenticated = $authenticated; }
	}
	
	$Table = AddWordTable -Hashtable $receiverSummary `
	-Columns receiverName, webURL, authenticated `
	-Headers "Name", "Website URL", "Auth?" `
	-AutoFit $wdAutoFitContent
	SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$receiverSummary = $Null	
	
	## detail
	foreach ($receiver in $receivers)
	{
		[System.Collections.Hashtable[]] $receiverDetail = @();
		$receiverName = $receiver.Name;
		$storename = $receiver.Store;
		$webURL = $receiver.webURL;
		$storeURL = $receiver.StoreURL;
		$authenticated = $receiver.Authenticated;
		$HTML5version = $receiver.HTML5Version;
		WriteWordLine 3 1 "Receiver for Web Site:  $receiverName"
		Write-Verbose "$(Get-Date):   Receiver site: $receiverName "
		$receiverDetail += @{ Data = "Website URL"; Value = $webURL; }
		$receiverDetail += @{ Data = "Store"; Value = $storeName; }
		$receiverDetail += @{ Data = "Store URL"; Value = $storeURL; }
		$receiverDetail += @{ Data = "Store Authenticated"; Value = $authenticated; }
		$recMethods = @($receiver.AuthMethods.AuthMethod);
		$authMethodLabel = "Authentication Methods";
		foreach ($recMethod in $recMethods)
		{
			$receiverDetail += @{ Data = $authMethodLabel; Value = $recMethod.Name; }
			$authMethodLabel = ""
		}
		$receiverDetail += @{ Data = "Citrix Receiver deployment"; Value = $receiver.Deployment; }
		$receiverDetail += @{ Data = "Receiver for HTML5 version"; Value = $HTML5version; }
		$Table = AddWordTable -Hashtable $receiverDetail -Columns Data,Value -List -AutoFit $wdAutoFitContent;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$receiverDetail = $Null		
	}
	
	$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters NetScaler Gateway"
	WriteWordLine 1 0 "NetScaler Gateway"
	WriteWordLine 0 0 ""
	$gateways = @($xmlDoc.StoreFront.Gateways.Gateway)

	## summary
	[System.Collections.Hashtable[]] $gatewaySummary = @();
	foreach ($gateway in $gateways)
	{
		$Name = $gateway.Name;
		$URL = $gateway.GatewayURL;
		$gatewaySummary += @{ gatewayName = $Name; URL = $URL; }
	}
	
	$Table = AddWordTable -Hashtable $gatewaySummary `
	-Columns gatewayName, URL `
	-Headers "Display Name", "Gateway URL" `
	-AutoFit $wdAutoFitFixed
	SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$gatewaySummary = $Null	
	
	## detail
	foreach ($gateway in $gateways)
	{
		[System.Collections.Hashtable[]] $gatewayDetail = @();
		$Name = $gateway.Name;
		$URL = $gateway.GatewayURL;
		$version = $gateway.Version;
		$subnetIP = $gateway.subnetIP;
		$logonType = $gateway.LogonType;
		$smartCardFallback = $gateway.SmartCardFallback;
		$callbackURL = $gateway.callbackURL;
		WriteWordLine 3 1 "Gateway:  $Name"
		Write-Verbose "$(Get-Date):   Gateway: $Name "
		$gatewayDetail += @{ Data = "Display name"; Value = $Name; }
		$gatewayDetail += @{ Data = "NetScaler Gateway URL"; Value = $URL; }
		$gatewayDetail += @{ Data = "Version"; Value = $version; }
		$gatewayDetail += @{ Data = "Subnet IP address"; Value = $subnetIP; }
		$gatewayDetail += @{ Data = "Logon type"; Value = $logonType; }
		If($smartCardFalback -ne "None")
		{
			$gatewayDetail += @{ Data = "Smart card fallback"; Value = $smartCardFallback; }
		}
		$gatewayDetail += @{ Data = "Callback URL"; Value = $callbackURL; }
		
		$STAs = @($gateway.STAs.STA);
		$STALabel = "STA URLs";
		foreach ($sta in $STAs)
		{
			$gatewayDetail += @{ Data = $STALabel; Value = $sta.Address; }
			$STALabel = ""
		}
		$gatewayDetail += @{ Data = "Enable session reliability"; Value = $gateway.SessionReliability; }
		$gatewayDetail += @{ Data = "Request tickets from 2 STAs"; Value = $gateway.Request2STAtickets; }
		$Table = AddWordTable -Hashtable $gatewayDetail -Columns Data,Value -List -AutoFit $wdAutoFitContent;
		$Table.Rows.SetLeftIndent($Indent1TabStops,$wdAdjustProportional)
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$gatewayDetail = $Null		
	}	
	
	#$Script:Selection.InsertNewPage()
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Beacons"
	WriteWordLine 1 0 "Beacons"
	WriteWordLine 0 0 ""
	
	[System.Collections.Hashtable[]] $beaconTable = @();
	## first do internal beacons
	$beacons = @($xmlDoc.StoreFront.Beacons.Internal.BeaconURL)	
	$beaconLabel = "Internal";
	foreach ($beacon in $beacons)
	{
		$beaconTable += @{ Data = $beaconLabel; Value = $beacon; }
		$beaconLabel = ""
	}
	## next do external beacons
	$beacons = @($xmlDoc.StoreFront.Beacons.External.BeaconURL)	
	$beaconLabel = "External";
	foreach ($beacon in $beacons)
	{
		$beaconTable += @{ Data = $beaconLabel; Value = $beacon; }
		$beaconLabel = ""
	}	
	$Table = AddWordTable -Hashtable $beaconTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
	$Table.Rows.SetLeftIndent($Indent0TabStops,$wdAdjustProportional)
	FindWordDocumentEnd
	WriteWordLine 0 0 " "
	$Table = $Null
	$beaconTable = $Null	

	# do we have hardware info?
	if ($xmlDoc.StoreFront.Hardware -ne $Null) 
	{
		$Script:Selection.InsertNewPage()
		$Chapter++
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix A: Hardware"
		WriteWordLine 1 0 "Appendix A: Hardware"
		WriteWordLine 0 0 ""
		
		$hardware = $xmlDoc.StoreFront.Hardware.General
		[System.Collections.Hashtable[]] $hardwareTable = @();
		$hardwareTable += @{ Data = "Manufacturer"; Value = $hardware.Manufacturer; }
		$hardwareTable += @{ Data = "Model"; Value = $hardware.Model; }
		$hardwareTable += @{ Data = "Domain"; Value = $hardware.Domain; }
		$hardwareTable += @{ Data = "RAM"; Value = $hardware.Ram; }
		$Table = AddWordTable -Hashtable $hardwareTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$hardwareTable = $Null	

		Write-Verbose "$(Get-Date):    Drive Info"
		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Drive Information"
		WriteWordLine 0 0 ""
		
		$drives = @($xmlDoc.StoreFront.Hardware.DriveInfo.Drive)
		[System.Collections.Hashtable[]] $hardwareTable = @();
		foreach ($drive in $drives)
		{
			$caption = $drive.Caption;
			$size = $drive.Size;
			$driveType = $drive.DriveType;
			$freespace = $drive.FreeSpace;
			If($driveType -eq "Local Disk" -or $driveType -eq "Network Drive")
				{$filesystem = $drive.FileSystem; $serialNumber = $drive.SerialNumber;} 
			Else 
				{$filesystem = " "; $serialNumber = " ";} 
			$hardwareTable += @{ caption = $caption; size = $size; filesystem = $filesystem; `
				freespace = $freespace; serialNumber = $serialNumber; driveType = $driveType }
		}	
		$Table = AddWordTable -Hashtable $hardwareTable `
		-Columns caption, size, filesystem, freespace, serialNumber, driveType `
		-Headers "Drive", "Size", "FileSystem", "Free Space", "Serial #", "Drive Type" `
		-AutoFit $wdAutoFitFixed
		SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
		FindWordDocumentEnd
		WriteWordLine 0 0 " "
		$Table = $Null
		$hardwareTable = $Null

		Write-Verbose "$(Get-Date):    Processor Info"
		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Processor Information"
		WriteWordLine 0 0 ""
		
		[int] $cnt = 0
		$cpus = @($xmlDoc.StoreFront.Hardware.CPUs.CPU)
		foreach ($cpu in $cpus)
		{
			++$cnt
			WriteWordLine 3 0 "CPU $($cnt)"
			[System.Collections.Hashtable[]] $hardwareTable = @();
			$hardwareTable += @{ Data = "Name"; Value = $cpu.Name; }
			$hardwareTable += @{ Data = "Description"; Value = $cpu.Description; }
			$hardwareTable += @{ Data = "Clock speed"; Value = $cpu.MaxClockSpeed; }
			$hardwareTable += @{ Data = "Number of cores"; Value = $cpu.NumberOfCores; }
			$hardwareTable += @{ Data = "Number of logical CPUs"; Value = $cpu.NumLogicalCPUs; }
			$hardwareTable += @{ Data = "Availability"; Value = $cpu.Availability; }
			$Table = AddWordTable -Hashtable $hardwareTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
			FindWordDocumentEnd
			WriteWordLine 0 0 " "
			$Table = $Null
			$hardwareTable = $Null
		}

		Write-Verbose "$(Get-Date):    Network Info"
		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Network Information"
		WriteWordLine 0 0 ""
		
		[int] $cnt = 0
		$nics = @($xmlDoc.StoreFront.Hardware.Network.NIC)
		foreach ($nic in $nics)
		{
			++$cnt
			WriteWordLine 3 0 "NIC $($cnt)"
			[System.Collections.Hashtable[]] $hardwareTable = @();
			$hardwareTable += @{ Data = "Name"; Value = $nic.Name; }
			$hardwareTable += @{ Data = "Connection type"; Value = $nic.ConnectionID; }
			$hardwareTable += @{ Data = "Availability"; Value = $nic.Availability; }
			$hardwareTable += @{ Data = "Mac address"; Value = $nic.PhyicalAddress; }
			$hardwareTable += @{ Data = "IP address"; Value = $nic.IPAddress; }
			$hardwareTable += @{ Data = "Subnet mask"; Value = $nic.SubnetMask; }
			$DNSsuffixes = @($nic.DNSSearchSuffixes.DNSDomain)
			$DNSLabel = "DNS Search Suffixes"
			foreach ($suffix in $DNSsuffixes)
			{
				$hardwareTable += @{ Data = $DNSLabel; Value = $($suffix); }
				$DNSLabel = ""
			}
			$hardwareTable += @{ Data = "WINS enabled"; Value = $nic.WINSEnabled; }
			$DNSServers = @($nic.DNSServers.DNSServer)
			$DNSLabel = "DNS Servers"
			foreach ($server in $DNSServers)
			{
				$hardwareTable += @{ Data = $DNSLabel; Value = $server; }
				$DNSLabel = ""
			}			
			$hardwareTable += @{ Data = "NetBIOS"; Value = $nic.NetBIOS; }
			$hardwareTable += @{ Data = "Enabled LMHosts"; Value = $nic.EnabledLMHosts; }
			$Table = AddWordTable -Hashtable $hardwareTable -Columns Data,Value -List -AutoFit $wdAutoFitFixed;
			FindWordDocumentEnd
			WriteWordLine 0 0 " "
			$Table = $Null
			$hardwareTable = $Null
		}
	}
	
	# do we have software info?
	if ($xmlDoc.StoreFront.Software -ne $Null) 
	{
		$Script:Selection.InsertNewPage()
		$Chapter++
		$appendix = "B"
		if ($xmlDoc.StoreFront.Hardware -eq $Null) { $appendix = "A" }
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix $($appendix): Software"
		WriteWordLine 1 0 "Appendix $($appendix): Software"
		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Installed Applications"
		Write-Verbose "$(Get-Date):    Installed Applications"
		WriteWordLine 0 0 ""
		$applications = @($xmlDoc.StoreFront.Software.InstalledApplications.Application)
		[System.Collections.Hashtable[]] $softwareTable = @();
		foreach ($application in $applications)
		{
			$softwareTable += @{ Name = $application.Name; version = $application.Version; }
		}
		$Table = AddWordTable -Hashtable $softwareTable `
		-Columns Name, Version `
		-Headers "Application Name", "Version" `
		-AutoFit $wdAutoFitContent
		SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
        FindWordDocumentEnd
        WriteWordLine 0 0 " "
		$Table = $Null
		$softwareTable = $Null	

		WriteWordLine 0 0 ""
		WriteWordLine 2 0 "Citrix Services"
		Write-Verbose "$(Get-Date):    Citrix Services"
		WriteWordLine 0 0 ""
		$services =  @($xmlDoc.StoreFront.Software.CitrixServices.Service)
		[System.Collections.Hashtable[]] $softwareTable = @();
		foreach ($service in $services)
		{
			$softwareTable += @{ Name = $service.Name; state = $service.State; startMode = $service.StartMode }
		}
		$Table = AddWordTable -Hashtable $softwareTable `
		-Columns Name, state, startMode -Headers "Service Name", "State", "Start Mode" `
		-AutoFit $wdAutoFitContent
		SetWordCellFormat -Collection $Table.Rows.Item(1).Cells -Bold -BackgroundColor $wdColorGray15;
        FindWordDocumentEnd
        WriteWordLine 0 0 " "
		$Table = $Null
		$softwareTable = $Null			
	}	
}
ElseIf($Text)
{

	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Host Information"
	Line 0 ""
	Line 0 "Host Information"
	Line 1 "Host Server `t`t$($hostInfo.ServerName)"
	Line 1 "StoreFront Version`t$($hostInfo.SFVersion)"
	Line 1 "As Of`t`t`t$($hostInfo.AsOf)"
	Line 0 " "
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Server Group"
	Line 0 "Server Group"
	Line 1 "Base URL`t`t$baseURL"
	Line 1 "Number of servers`t$memberCount"
	If ($memberCount -gt 1)
	{
		Line 1 "Configuration`t`tLast propagated from $($config.ToLower())"
	}
	Line 0 ""
	
	If ($memberCount -gt 1)
	{	
		Line 0 "Server Details"
		foreach ($mem in $members.member)
		{
			Write-Verbose "$(Get-Date):   Server: $($mem.name) "
			$memName = $mem.name.ToUpper();
			if ($memName -eq $config.ToUpper())
			{
				$sync = "Propagated changes at $($mem.lastSync)"
			} Else {
				$sync = "Synchronized changes with $($config.ToUpper()) at $($mem.lastSync)"
			}
			if ($memName -eq $hostInfo.ServerName.ToUpper()) { $memName += " (this server)" }
			
			Line 1 "Server Name`t`t$memName"
			Line 1 "Synchronization Status`t$sync"
			Line 0 ""
		}
		Line 0 ""
	}


	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Authentication Service"
	Line 0 "Authentication"
	Line 0 ""
	Line 0 "   Authentication Methods"
	$authentication = $xmldoc.StoreFront.Authentication
	$methods = @($authentication.Methods.Method)

	foreach ($method in $methods)
	{
		Line 1 "Authentication Method`t$($method.name)"
		Line 1 "Enabled`t`t`t$($method.enabled)"
	}
	Line 0 " "
	
	Line 0 "   Authentication Service"
	Line 0 ""

	Line 1 "Token validation service`t$($authentication.tokenURL)"
	Line 1 "Number of enabled methods`t$($authentication.EnabledMethods)"
	$sslExpiration = ([datetime] $authentication.SSLExpiration).ToString('MM/dd/yyyy')
	If([int] $authentication.daysUntilExpiration -lt 0)
	{
		$authStatus = "Certificate has expired ($($sslExpiration))."
	}
	ElseIf([int] $authentication.daysUntilExpiration -lt 30)
	{
		$authStatus = "Certificate is about to expire ($($sslExpiration))."
	}
	ElseIf($authentication.status.Contains("HTTPS"))
	{
		$authStatus = "Service using HTTPS."
	}
	Else
	{
		$authStatus = "Service using HTTP."
	}	
	Line 1 "Status`t`t`t`t$($authStatus)"
	Line 0 " "
	
	$trustedDomains = $authentication.TrustedDomains
	$showDomains = $trustedDomains.ShowDomains
	Line 0 "   Trusted Domains"
	Line 1 "Allow users to log on from`t$($trustedDomains.AllowLogOn)"
	$domains = @($trustedDomains.Domain)
	$firstItem = $True
	foreach($item in $domains) 
	{
		if($firstItem -eq $True) 
			{Line 1 "Trusted domains`t`t`t$($item.name)"; $firstItem = $False;} 
		else 
			{Line 1 "`t`t`t`t$($item.name)"} 
	}	

	Line 1 "Default domain`t`t`t$($trustedDomains.DefaultDomain)"
	If($showDomains -ne $Null)
	{
		Line 1 "Show domains list in logon page`t$($showDomains)"
	}
	Line 1 "Allow users to change passwords`t$($authentication.changePW)"
	Line 0 " "
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Stores"
	Line 0 "Stores"
	Line 0 ""
	$stores = @($xmldoc.StoreFront.Stores.Store)

	## store details
	foreach ($store in $stores)
	{
		Write-Verbose "$(Get-Date):   Store: $($store.Name) "
		Line 1 "Store: $($store.Name)"
		Line 2 "Authenticated`t`t$($store.Authenticated)"
		Line 2 "Advertised`t`t$($store.Advertised)"
		Line 2 "Locked`t`t`t$($store.Locked)"
		Line 2 "URL`t`t`t$($store.storeURL)"
		Line 2 "Access`t`t`t$($store.Access)"
		Line 0 " "
		if(!($store.ResourceFilters -eq $Null))
		{
			Line 2 "Resource Filters"
			Line 0 ""
			
			$includedTypes = @($store.ResourceFilters.IncludedTypes.includedType);
			$includedKeywords = @($store.ResourceFilters.IncludedKeywords.includedKeyword);
			$excludedKeywords = @($store.ResourceFilters.ExcludedKeywords.excludedKeyword);

			Line 3 "Included Types"
			foreach($type in $includedTypes) {Line 4 $type}
			Line 0 ""
			Line 3 "Included Keywords"
			foreach($type in $includedKeywords) {Line 4 $type}
			Line 0 ""
			Line 3 "Excluded Keywords"
			foreach($type in $excludedKeywords) {Line 4 $type}

			Line 0 " "
		
		}
		
		$farms = @($store.Farms.Farm)

		## delivery controller detail for the store
		foreach ($farm in $farms)
		{
			Line 2 "Delivery controller: $($farm.farmName)"
			Line 3 "Type`t`t$($farm.FarmType)"
			$servers = @($farm.Servers.Server)
			
			$firstItem = $True
			foreach($item in $servers) 
			{
				if($firstItem -eq $True) 
					{Line 3 "Servers`t`t$($item.name)"; $firstItem = $False;} 
				else 
					{Line 3 "`t`t$($item.name)"} 
			}

			If($farm.farmType -eq "XenDesktop" -or $farm.farmType -eq "XenApp")
			{
				Line 3 "Transport Type`t$($farm.TransportType)"
				Line 3 "Port`t`t$($farm.XMLPort)"
				Line 3 "Load balanced`t$($farm.LoadBalance)"
			} 
			Elseif($farm.farmType -eq "AppController")
			{
				Line 3 "Port`t`t$($farm.XMLPort)"
			} 
			Line 0 " "
		}

		Line 2 "Citrix Online Integration"
		Line 3 "GoToMeeting`t$($store.CitrixOnline.GoToMeeting)"
		Line 3 "GoToWebinar`t$($store.CitrixOnline.GoToWebinar)"
		Line 3 "GoToTraining`t$($store.CitrixOnline.GoToTraining)"
		Line 0 " "

		$remoteAccess = $store.RemoteAccess
		Line 2 "Remote Access"
		Line 3 "Remote access`t`t`t$($remoteAccess.RemoteType)"
		if ($remoteAccess.RemoteType -ne "None") 
		{
			$appliances = @($remoteAccess.RemoteGW)
			$firstItem = $True
			foreach($item in $appliances) 
			{
				if($firstItem -eq $True) 
					{Line 3 "NetScaler Gateway appliances`t$($item)"; $firstItem = $False;} 
				else 
					{Line 3 "`t`t`t`t$($item)"} 
			}
			Line 3 "Default appliance`t`t$($remoteAccess.DefaultGW)"
		}
		Line 0 " "
	}

	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Receiver for Web"
	Line 0 "Receiver for Web"
	Line 0 ""
	$receivers = @($xmlDoc.StoreFront.ReceiverForWeb.Receiver)
	
	## detail
	foreach ($receiver in $receivers)
	{
			$receiverName = $receiver.Name;
			$storename = $receiver.Store;
			$webURL = $receiver.webURL;
			$storeURL = $receiver.StoreURL;
			$authenticated = $receiver.Authenticated;
			$HTML5version = $receiver.HTML5Version;
			Write-Verbose "$(Get-Date):   Receiver site: $receiverName "
			Line 1 "Receiver for Web Site: $($receiverName)"
			Line 2 "Website URL`t`t`t$($webURL)"
			Line 2 "Store`t`t`t`t$($storeName)"
			Line 2 "Store URL`t`t`t$($storeURL)"
			Line 2 "Store Authenticated`t`t$($authenticated)"

			$recMethods = @($receiver.AuthMethods.AuthMethod);
			$firstItem = $True
			foreach($item in $recMethods) 
			{
				if($firstItem -eq $True) 
					{Line 2 "Authentication Methods`t`t$($item.name)"; $firstItem = $False;} 
				else 
					{Line 2 "`t`t`t`t$($item.name)"} 
			}		
			
			Line 2 "Citrix Receiver deployment`t$($receiver.Deployment)"
			if($HTML5version -ne "0.0.0.0")
			{
				Line 2 "Receiver for HTML5 version`t$($HTML5version)"
			}
			Line 0 " "
	}	
		
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters NetScaler Gateway"
	Line 0 "NetScaler Gateway"
	Line 0 ""
	$gateways = @($xmlDoc.StoreFront.Gateways.Gateway)

	## detail
	foreach ($gateway in $gateways)
	{
		$Name = $gateway.Name;
		$URL = $gateway.GatewayURL;
		$version = $gateway.Version;
		$subnetIP = $gateway.subnetIP;
		$logonType = $gateway.LogonType;
		$smartCardFallback = $gateway.SmartCardFallback;
		$callbackURL = $gateway.callbackURL;
		Line 1 "Gateway: $($Name)"
		Line 2 "NetScaler Gateway URL`t`t$($URL)"
		Line 2 "Version`t`t`t`t$($version)"
		Line 2 "Subnet IP address`t`t$($subnetIP)"
		Line 2 "Logon type`t`t`t$($logonType)"

		If($smartCardFalback -ne "None")
		{
			Line 2 "Smart card fallback`t`t$($smartCardFallback)"
		}
		Line 2 "Callback URL`t`t`t$($callbackURL)"
		
		$STAs = @($gateway.STAs.STA);
		$firstItem = $True
		foreach($item in $STAs) 
		{
			if($firstItem -eq $True) 
				{Line 2 "STA URLs`t`t`t$($item.Address)"; $firstItem = $False;} 
			else 
				{Line 2 "`t`t`t`t$($item.Address)"} 
		}			

		Line 2 "Enable session reliability`t$($gateway.SessionReliability)"
		Line 2 "Request tickets from 2 STAs`t$($gateway.Request2STAtickets)"
		Line 0 " "	
	}		

	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Beacons"
	Line 0 "Beacons"
	Line 0 " "
	$beacons = @($xmlDoc.StoreFront.Beacons.Internal.BeaconURL)	
	Line 1 "Internal beacon`t`t$($beacons[0])"
	Line 0 " "
	$beacons = @($xmlDoc.StoreFront.Beacons.External.BeaconURL)	
	$firstItem = $True
	foreach($item in $beacons) 
	{
		if($firstItem -eq $True) 
			{Line 1 "External beacons`t$($item)"; $firstItem = $False;} 
		else 
			{Line 1 "`t`t`t$($item)"} 
	}				
	Line 0 " "
	
	# do we have hardware info?
	if ($xmlDoc.StoreFront.Hardware -ne $Null) 
	{
		$Chapter++
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix A: Hardware"
		Line 0 "Appendix A: Hardware"
		Line 0 ""
		
		$hardware = $xmlDoc.StoreFront.Hardware.General
		Line 1 "General Information"
		Line 2 "Model`t$($hardware.Model)"
		Line 2 "Domain`t$($hardware.Domain)"
		Line 2 "RAM`t$($hardware.Ram)"
		Line 0 " "

		Write-Verbose "$(Get-Date):    Drive Info"
		Line 1 "Drive Information"
		Line 0 ""
	
		$drives = @($xmlDoc.StoreFront.Hardware.DriveInfo.Drive)

		foreach ($drive in $drives)
		{
			$caption = $drive.Caption;
			$size = $drive.Size;
			$driveType = $drive.DriveType;
			$freespace = $drive.FreeSpace;
			If($driveType -eq "Local Disk" -or $driveType -eq "Network Drive")
				{$filesystem = $drive.FileSystem; $serialNumber = $drive.SerialNumber;} 
			Else 
				{$filesystem = " "; $serialNumber = " ";}

			Line 1 "   Drive $($caption)"
			Line 2 "Size`t$($size)"
			Line 2 "File System`t$($filesystem)"
			Line 2 "Free Space`t$($freespace)"
			Line 2 "Serial #`t$($serialNumber)"
			Line 2 "Drive Type`t$($driveType)"
		}	
		Line 0 ""
		
		Write-Verbose "$(Get-Date):    Processor Info"
		Line 1 "Processor Information"
		Line 0 ""
		
		[int] $cnt = 0
		$cpus = @($xmlDoc.StoreFront.Hardware.CPUs.CPU)
		foreach ($cpu in $cpus)
		{
			++$cnt
			Line 1 "   CPU $($cnt)"
			Line 2 "Name`t`t`t$($cpu.Name)"
			Line 2 "Description`t`t$($cpu.Description)"
			Line 2 "Clock speed`t`t$($cpu.MaxClockSpeed)"
			Line 2 "Number of cores`t`t$($cpu.NumberOfCores)"
			Line 2 "Number of logical CPUs`t$($cpu.NumLogicalCPUs)"
			Line 2 "Availability`t`t$($cpu.Availability)"
			Line 0 " "		
		}

		Write-Verbose "$(Get-Date):    Network Info"
		Line 1 "Network Information"
		Line 0 ""
		
		[int] $cnt = 0
		$nics = @($xmlDoc.StoreFront.Hardware.Network.NIC)
		foreach ($nic in $nics)
		{
			++$cnt
			Line 1 "   NIC $($cnt)"
			Line 2 "Name`t`t`t$($nic.Name)"
			Line 2 "Connection type`t`t$($nic.ConnectionID)"
			Line 2 "Availability`t`t$($nic.Availability)"
			Line 2 "Mac address`t`t$($nic.PhyicalAddress)"
			Line 2 "IP address`t`t$($nic.IPAddress)"
			Line 2 "Subnet mask`t`t$($nic.SubnetMask)"

			$DNSsuffixes = @($nic.DNSSearchSuffixes.DNSDomain)
			$firstItem = $True
			foreach($item in $DNSsuffixes) 
			{
				if($firstItem -eq $True) 
					{Line 2 "DNS Search Suffixes`t$($item)"; $firstItem = $False;} 
				else 
					{Line 2 "`t`t`t$($item)"} 
			}						
			Line 2 "WINS enabled`t`t$($nic.WINSEnabled)"

			$DNSServers = @($nic.DNSServers.DNSServer)
			$firstItem = $True
			foreach($item in $DNSServers) 
			{
				if($firstItem -eq $True) 
					{Line 2 "DNS Servers`t`t$($item)"; $firstItem = $False;} 
				else 
					{Line 2 "`t`t`t$($item)"} 
			}						
			Line 2 "NetBIOS`t`t`t$($nic.NetBIOS)"
			Line 2 "Enabled LMHosts`t`t$($nic.EnabledLMHosts)"
			Line 0 " "		
		}
	}
	
	# do we have software info?
	if ($xmlDoc.StoreFront.Software -ne $Null) 
	{
		$Chapter++
		$appendix = "B"
		if ($xmlDoc.StoreFront.Hardware -eq $Null) { $appendix = "A" }
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix $($appendix): Software"
		Line 1 "Appendix $($appendix): Software"
		Line 0 ""

		Write-Verbose "$(Get-Date):    Installed Applications"
		Line 1 "   Installed Applications"
		$applications = @($xmlDoc.StoreFront.Software.InstalledApplications.Application)

		foreach ($application in $applications)
		{
			Line 2 "Application name`t$($application.Name)"
			Line 2 "Version`t`t`t$($application.Version)"
			Line 0 ""
		}
		Line 0 " "

		Write-Verbose "$(Get-Date):    Citrix Services"
		Line 1 "   Citrix Services"
		$services =  @($xmlDoc.StoreFront.Software.CitrixServices.Service)

		foreach ($service in $services)
		{
			Line 2 "Service name`t`t$($service.Name)"
			Line 2 "State`t`t`t$($service.State)"
			Line 2 "Start mode`t`t$($service.StartMode)"
			Line 0 ""
		}
		Line 0 " "
	}	
}
ElseIf($HTML)
{
	SetupHTML 
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Host Information"
	WriteHTMLLine 0 0 ""
	WriteHTMLLine 1 0 "Host Information"
	$rowdata = @()
	$columnHeaders = @("Host Server",($htmlsilver -bor $htmlbold),$hostInfo.ServerName,$htmlwhite)
	$rowdata += @(,('StoreFront Version',($htmlsilver -bor $htmlbold),$hostInfo.SFVersion,$htmlwhite))
	$rowdata += @(,('As Of',($htmlsilver -bor $htmlbold),$hostInfo.AsOf,$htmlwhite))
	FormatHTMLTable "" "30%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Server Group"
	WriteHTMLLine 1 0 "Server Group"
	
	$rowdata = @()
	$columnHeaders = @("Base URL",($htmlsilver -bor $htmlbold),$baseURL,$htmlwhite)
	$rowdata += @(,('Number of servers',($htmlsilver -bor $htmlbold),$memberCount,$htmlwhite))
	If ($memberCount -gt 1)
	{
		$rowdata += @(,('Configuration',($htmlsilver -bor $htmlbold),"Last propagated from $($config.ToLower())",$htmlwhite))
	}
	FormatHTMLTable "Group Details" "30%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 ""
	
	If ($memberCount -gt 1)
	{	
		WriteHTMLLine 0 0 ""
		$rowdata = @()
		$columnHeaders = @("Server Name",($htmlsilver -bor $htmlbold),"Synchronization Status",($htmlsilver -bor $htmlbold))

		foreach ($mem in $members.member)
		{
			Write-Verbose "$(Get-Date):   Server: $($mem.name) "
			$memName = $mem.name.ToUpper();
			if ($memName -eq $config.ToUpper())
			{
				$sync = "Propagated changes at $($mem.lastSync)"
			} Else {
				$sync = "Synchronized changes with $($config.ToUpper()) at $($mem.lastSync)"
			}
			if ($memName -eq $hostInfo.ServerName.ToUpper()) { $memName += " (this server)" }
			$rowdata += @(,($memName,$htmlwhite,$sync,$htmlwhite))
		}
		
		FormatHTMLTable "Server Details" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 ""
	}

	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Authentication Service"
	WriteHTMLLine 1 0 "Authentication"
	WriteHTMLLine 0 0 ""

	$authentication = $xmldoc.StoreFront.Authentication
	$methods = @($authentication.Methods.Method)
	$rowdata = @()
	$columnHeaders = @("Authentication Method",($htmlsilver -bor $htmlbold),"Enabled",($htmlsilver -bor $htmlbold))

	foreach ($method in $methods)
	{
		$methName = $method.name;
		$enabled = $method.enabled;
		$rowdata += @(,($methName,$htmlwhite,$enabled,$htmlwhite))
	}
	
	FormatHTMLTable "Authentication Methods" "50%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "
	
	WriteHTMLLine 1 0 "Authentication Service"
	WriteHTMLLine 0 0 ""
	$rowdata = @()
	$columnHeaders = @("Token validation service",($htmlsilver -bor $htmlbold),$authentication.tokenURL,$htmlwhite)
	$rowdata += @(,('Number of enabled methods',($htmlsilver -bor $htmlbold),$authentication.EnabledMethods,$htmlwhite))
	$sslExpiration = ([datetime] $authentication.SSLExpiration).ToString('MM/dd/yyyy')
	If([int] $authentication.daysUntilExpiration -lt 0)
	{
		$authStatus = "Certificate has expired ($($sslExpiration))."
		$HighlightedCells = $htmlred
	}
	ElseIf([int] $authentication.daysUntilExpiration -lt 30)
	{
		$authStatus = "Certificate is about to expire ($($sslExpiration))."
		$HighlightedCells = $htmlred
	}
	ElseIf($authentication.status.Contains("HTTPS"))
	{
		$authStatus = "Service using HTTPS."
		$HighlightedCells = $htmlwhite
	}
	Else
	{
		$authStatus = "Service using HTTP."
		$HighlightedCells = $htmlwhite
	}	
	$rowdata += @(,('Status',($htmlsilver -bor $htmlbold),$authStatus,$HighlightedCells))
	FormatHTMLTable "Overview" "60%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "
	
	$trustedDomains = $authentication.TrustedDomains
	$showDomains = $trustedDomains.ShowDomains
	$rowdata = @()
	$columnHeaders = @("Allow users to log on from",($htmlsilver -bor $htmlbold),$trustedDomains.AllowLogOn,$htmlwhite)
	$domains = @($trustedDomains.Domain)
	$strItems = ""
	foreach($item in $domains) {if($strItems -eq ""){$strItems += "$($item.name)"} else {$strItems += "<br>$($item.name)"} }	
	$rowdata += @(,("Trusted domains",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))
	$rowdata += @(,("Default domain",($htmlsilver -bor $htmlbold),$trustedDomains.DefaultDomain,$htmlwhite))
	If($showDomains -ne $Null)
	{
		$rowdata += @(,("Show domains list in logon page",($htmlsilver -bor $htmlbold),$showDomains,$htmlWhite))
	}
	$rowdata += @(,("Allow users to change passwords",($htmlsilver -bor $htmlbold),$authentication.changePW,$htmlWhite))
	FormatHTMLTable "Trusted Domains" "60%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Stores"
	WriteHTMLLine 1 0 "Stores"
	WriteHTMLLine 0 0 ""
	$stores = @($xmldoc.StoreFront.Stores.Store)
	
	## store summary
	$rowdata = @()
	$columnHeaders = @("Name",($htmlsilver -bor $htmlbold),"Authenticated",($htmlsilver -bor $htmlbold),"Advertised",($htmlsilver -bor $htmlbold),"Locked",($htmlsilver -bor $htmlbold))
	foreach ($store in $stores)
	{
		$storeName = $store.Name;
		$authenticated = $store.Authenticated;
		$locked = $store.Locked;
		$advertised = $store.Advertised;
		$storeURL = $store.storeURL;
		$access = $store.Access;
		$rowdata += @(,($storeName,$htmlWhite,$authenticated,$htmlWhite,$advertised,$htmlWhite,$locked,$htmlWhite))
	}	
	FormatHTMLTable "" "50%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "

	## store details
	foreach ($store in $stores)
	{
		Write-Verbose "$(Get-Date):   Store: $($store.Name) "
		$rowdata = @()
		$columnHeaders = @("Authenticated",($htmlsilver -bor $htmlbold),$store.Authenticated,$htmlWhite)
		$rowdata += @(,("Advertised",($htmlsilver -bor $htmlbold),$store.Advertised,$htmlWhite))
		$rowdata += @(,("Locked",($htmlsilver -bor $htmlbold),$store.Locked,$htmlWhite))
		$rowdata += @(,("URL",($htmlsilver -bor $htmlbold),$store.storeURL,$htmlWhite))
		$rowdata += @(,("Access",($htmlsilver -bor $htmlbold),$store.Access,$htmlWhite))
		FormatHTMLTable "Store: $($store.Name)" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "

		if(!($store.ResourceFilters -eq $Null))
		{
			$includedTypes = @($store.ResourceFilters.IncludedTypes.includedType);
			$includedKeywords = @($store.ResourceFilters.IncludedKeywords.includedKeyword);
			$excludedKeywords = @($store.ResourceFilters.ExcludedKeywords.excludedKeyword);
			$strType = ""
			foreach($type in $includedTypes) {if($strType -eq "") {$strType += "$type"} else {$strType += "<br>$type"} }
			$strIncKeywords = ""
			foreach($type in $includedKeywords) {if($strIncKeywords -eq "") {$strIncKeywords += "$type"} else {$strIncKeywords += "<br>$type"} }
			$strExtKeywords = ""
			foreach($type in $excludedKeywords) {if($strExtKeywords -eq "") {$strExtKeywords += "$type"} else {$strExtKeywords += "<br>$type"} }
			$rowdata = @()
			$columnHeaders = @("Included Types",($htmlsilver -bor $htmlbold),"Included Keywords",($htmlsilver -bor $htmlbold), "Excluded Keywords",($htmlsilver -bor $htmlbold))
			$rowdata += @(,($strType,$htmlWhite,$strIncKeywords,$htmlWhite, $strExtKeywords,$htmlWhite))		
			FormatHTMLTable "Resource Filtering" "50%" -rowArray $rowdata -columnArray $columnHeaders
			WriteHTMLLine 0 0 " "
		
		}
		
		## delivery controller summary for the store

		$rowdata = @()
		$columnHeaders = @("Name",($htmlsilver -bor $htmlbold),"Type",($htmlsilver -bor $htmlbold))
		$farms = @($store.Farms.Farm)

		foreach ($farm in $farms)
		{
			$rowdata += @(,($farm.FarmName,$htmlWhite,$farm.FarmType,$htmlWhite))
		}
		FormatHTMLTable "Delivery controllers" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "

		## delivery controller detail for the store
		foreach ($farm in $farms)
		{		
			$rowdata = @()
			$columnHeaders = @("Type",($htmlsilver -bor $htmlbold),$farm.FarmType,$htmlWhite)
			$servers = @($farm.Servers.Server)
			
			$strItems = ""
			foreach($item in $servers) 
			{
				if($strItems -eq "") 
					{$strItems += "$($item.name)"} 
				else 
					{$strItems += "<br>$($item.name)"} 
			}
			$rowdata += @(,("Servers",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))

			If($farm.farmType -eq "XenDesktop" -or $farm.farmType -eq "XenApp")
			{
				$rowdata += @(,("Transport Type",($htmlsilver -bor $htmlbold),$farm.TransportType,$htmlWhite))
				$rowdata += @(,("Port",($htmlsilver -bor $htmlbold),$farm.XMLPort,$htmlWhite))
				$rowdata += @(,("Load balanced",($htmlsilver -bor $htmlbold),$farm.LoadBalance,$htmlWhite))
			} 
			Elseif($farm.farmType -eq "AppController")
			{
				$rowdata += @(,("Port",($htmlsilver -bor $htmlbold),$farm.XMLPort,$htmlWhite))
			} 
			FormatHTMLTable "Delivery controller: $($farm.farmName)" "50%" -rowArray $rowdata -columnArray $columnHeaders
			WriteHTMLLine 0 0 " "
		}

		$rowdata = @()
		$columnHeaders = @("GoToMeeting",($htmlsilver -bor $htmlbold),$store.CitrixOnline.GoToMeeting,$htmlWhite)
		$rowdata += @(,("GoToWebinar",($htmlsilver -bor $htmlbold),$store.CitrixOnline.GoToWebinar,$htmlWhite))
		$rowdata += @(,("GoToTraining",($htmlsilver -bor $htmlbold),$store.CitrixOnline.GoToTraining,$htmlWhite))
		FormatHTMLTable "Citrix Online Integration" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "

		$remoteAccess = $store.RemoteAccess
		$rowdata = @()
		$columnHeaders = @("Remote access",($htmlsilver -bor $htmlbold),$remoteAccess.RemoteType,$htmlWhite)
		if ($remoteAccess.RemoteType -ne "None") 
		{
			$appliances = @($remoteAccess.RemoteGW) -join "<br>"
			$rowdata += @(,("NetScaler Gateway appliances",($htmlsilver -bor $htmlbold),$appliances,$htmlWhite))
			$rowdata += @(,("Default appliance",($htmlsilver -bor $htmlbold),$remoteAccess.DefaultGW,$htmlWhite))
		}
		FormatHTMLTable "Remote Access" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "
			
	}
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Receiver for Web"
	WriteHTMLLine 1 0 "Receiver for Web"
	WriteHTMLLine 0 0 ""
	$receivers = @($xmlDoc.StoreFront.ReceiverForWeb.Receiver)
	
	## summary
	$rowdata = @()
	$columnHeaders = @("Name",($htmlsilver -bor $htmlbold),"Website URL",($htmlsilver -bor $htmlbold), "Auth?",($htmlsilver -bor $htmlbold))

	foreach ($receiver in $receivers)
	{
			$receiverName = $receiver.Name;
			$webURL = $receiver.webURL;
			$authenticated = $receiver.Authenticated;
			$rowdata += @(,($receiverName,$htmlWhite,$webURL,$htmlWhite, $authenticated,$htmlWhite))
	}
	FormatHTMLTable "" "50%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "
	
	## detail
	foreach ($receiver in $receivers)
	{
			$receiverName = $receiver.Name;
			$storename = $receiver.Store;
			$webURL = $receiver.webURL;
			$storeURL = $receiver.StoreURL;
			$authenticated = $receiver.Authenticated;
			$HTML5version = $receiver.HTML5Version;
			Write-Verbose "$(Get-Date):   Receiver site: $receiverName "
			$columnHeaders = @("Website URL",($htmlsilver -bor $htmlbold),$webURL,$htmlWhite)
			$rowdata = @()
			$rowdata += @(,("Store",($htmlsilver -bor $htmlbold),$storeName,$htmlWhite))
			$rowdata += @(,("Store URL",($htmlsilver -bor $htmlbold),$storeURL,$htmlWhite))
			$rowdata += @(,("Store Authenticated",($htmlsilver -bor $htmlbold),$authenticated,$htmlWhite))

			$recMethods = @($receiver.AuthMethods.AuthMethod);
			$strItems = ""
			foreach($item in $recMethods) 
			{
				if($strItems -eq "") 
					{$strItems += "$($item.name)"} 
				else 
					{$strItems += "<br>$($item.name)"} 
			}
			$rowdata += @(,("Authentication Methods",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))
			$rowdata += @(,("Citrix Receiver deployment",($htmlsilver -bor $htmlbold),$receiver.Deployment,$htmlWhite))
			if($HTML5version -ne "0.0.0.0")
			{
				$rowdata += @(,("Receiver for HTML5 version",($htmlsilver -bor $htmlbold),$HTML5version,$htmlWhite))
			}
			FormatHTMLTable "Receiver for Web Site:  $receiverName" "50%" -rowArray $rowdata -columnArray $columnHeaders
			WriteHTMLLine 0 0 " "
	}	
		
	
	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters NetScaler Gateway"
	WriteHTMLLine 1 0 "NetScaler Gateway"
	WriteHTMLLine 0 0 ""
	$gateways = @($xmlDoc.StoreFront.Gateways.Gateway)

	## summary
	$columnHeaders = @("Display Name",($htmlsilver -bor $htmlbold),"Gateway URL",($htmlsilver -bor $htmlbold))
	$rowdata = @()

	foreach ($gateway in $gateways)
	{
		$Name = $gateway.Name;
		$URL = $gateway.GatewayURL;
		$rowdata += @(,($Name,$htmlWhite,$URL,$htmlWhite))
	}
	FormatHTMLTable "" "50%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "

	## detail
	foreach ($gateway in $gateways)
	{
		$Name = $gateway.Name;
		$URL = $gateway.GatewayURL;
		$version = $gateway.Version;
		$subnetIP = $gateway.subnetIP;
		$logonType = $gateway.LogonType;
		$smartCardFallback = $gateway.SmartCardFallback;
		$callbackURL = $gateway.callbackURL;
		$columnHeaders = @("Display name",($htmlsilver -bor $htmlbold),$Name,$htmlWhite)
		$rowdata = @()
		$rowdata += @(,("NetScaler Gateway URL",($htmlsilver -bor $htmlbold),$URL,$htmlWhite))
		$rowdata += @(,("Version",($htmlsilver -bor $htmlbold),$version,$htmlWhite))
		$rowdata += @(,("Subnet IP address",($htmlsilver -bor $htmlbold),$subnetIP,$htmlWhite))
		$rowdata += @(,("Logon type",($htmlsilver -bor $htmlbold),$logonType,$htmlWhite))

		If($smartCardFalback -ne "None")
		{
			$rowdata += @(,("Smart card fallback",($htmlsilver -bor $htmlbold),$smartCardFallback,$htmlWhite))
		}
		$rowdata += @(,("Callback URL",($htmlsilver -bor $htmlbold),$callbackURL,$htmlWhite))
		
		$STAs = @($gateway.STAs.STA);
		$strItems = ""
		foreach($item in $STAs) 
		{
			if($strItems -eq "") 
				{$strItems += "$($item.Address)"} 
			else 
				{$strItems += "<br>$($item.Address)"} 
		}		

		$rowdata += @(,("STA URLs",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))
		$rowdata += @(,("Enable session reliability",($htmlsilver -bor $htmlbold),$gateway.SessionReliability,$htmlWhite))
		$rowdata += @(,("Request tickets from 2 STAs",($htmlsilver -bor $htmlbold),$gateway.Request2STAtickets,$htmlWhite))
		FormatHTMLTable "Gateway:  $Name" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "	
	}		

	$Chapter++
	Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Beacons"

	$beacons = @($xmlDoc.StoreFront.Beacons.Internal.BeaconURL)	
	$strItems = ""
	foreach($item in $beacons) {if($strItems -eq "") {$strItems += "$($item)"} else {$strItems += "<br>$($item)"} }			
	$internalBeacon = $strItems
	$beacons = @($xmlDoc.StoreFront.Beacons.External.BeaconURL)	
	foreach($item in $beacons) {if($strItems -eq "") {$strItems += "$($item)"} else {$strItems += "<br>$($item)"} }			
	$externalBeacons = $strItems

	$columnHeaders = @("Internal",($htmlsilver -bor $htmlbold),"External",($htmlsilver -bor $htmlbold))
	$rowdata = @()
	$rowdata += @(,($internalBeacon,$htmlWhite,$externalBeacons))

	FormatHTMLTable "Beacons" "50%" -rowArray $rowdata -columnArray $columnHeaders
	WriteHTMLLine 0 0 " "

	# do we have hardware info?
	if ($xmlDoc.StoreFront.Hardware -ne $Null) 
	{
		$Chapter++
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix A: Hardware"
		WriteHTMLLine 1 0 "Appendix A: Hardware"
		WriteHTMLLine 0 0 ""
		
		$hardware = $xmlDoc.StoreFront.Hardware.General
		$columnHeaders = @("Manufacturer",($htmlsilver -bor $htmlbold),$hardware.Manufacturer,$htmlWhite)
		$rowdata = @()
		$rowdata += @(,("Model",($htmlsilver -bor $htmlbold),$hardware.Model,$htmlWhite))
		$rowdata += @(,("Domain",($htmlsilver -bor $htmlbold),$hardware.Domain,$htmlWhite))
		$rowdata += @(,("RAM",($htmlsilver -bor $htmlbold),$hardware.Ram,$htmlWhite))
		FormatHTMLTable "General info" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "

		Write-Verbose "$(Get-Date):    Drive Info"
		WriteHTMLLine 1 0 "Drive Information"
		WriteHTMLLine 0 0 ""
	
		$drives = @($xmlDoc.StoreFront.Hardware.DriveInfo.Drive)
		$columnHeaders = @("Drive",($htmlsilver -bor $htmlbold),"Size",($htmlsilver -bor $htmlbold),"File System",($htmlsilver -bor $htmlbold),"Free Space",($htmlsilver -bor $htmlbold),"Serial #",($htmlsilver -bor $htmlbold),"Drive Type",($htmlsilver -bor $htmlbold))
		$rowdata = @()

		foreach ($drive in $drives)
		{
			$caption = $drive.Caption;
			$size = $drive.Size;
			$driveType = $drive.DriveType;
			$freespace = $drive.FreeSpace;
			If($driveType -eq "Local Disk" -or $driveType -eq "Network Drive")
				{$filesystem = $drive.FileSystem; $serialNumber = $drive.SerialNumber;} 
			Else 
				{$filesystem = " "; $serialNumber = " ";}
				
			$rowdata += @(,($caption,$htmlWhite,$size,$htmlWhite,$filesystem,$htmlWhite,$freespace,$htmlWhite,$serialNumber,$htmlWhite,$driveType,$htmlWhite))

		}	

		FormatHTMLTable "Drive info" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "		

		Write-Verbose "$(Get-Date):    Processor Info"
		WriteHTMLLine 1 0 "Processor Information"
		WriteHTMLLine 0 0 ""
		
		[int] $cnt = 0
		$cpus = @($xmlDoc.StoreFront.Hardware.CPUs.CPU)
		foreach ($cpu in $cpus)
		{
			$rowdata = @()
			++$cnt
			$columnHeaders = @("Name",($htmlsilver -bor $htmlbold),$cpu.Name,$htmlWhite)
			$rowdata += @(,("Description",($htmlsilver -bor $htmlbold),$cpu.Description,$htmlWhite))
			$rowdata += @(,("Clock speed",($htmlsilver -bor $htmlbold),$cpu.MaxClockSpeed,$htmlWhite))
			$rowdata += @(,("Number of cores",($htmlsilver -bor $htmlbold),$cpu.NumberOfCores,$htmlWhite))
			$rowdata += @(,("Number of logical CPUs",($htmlsilver -bor $htmlbold),$cpu.NumLogicalCPUs,$htmlWhite))
			$rowdata += @(,("Availability",($htmlsilver -bor $htmlbold),$cpu.Availability,$htmlWhite))

			FormatHTMLTable "CPU $($cnt)" "50%" -rowArray $rowdata -columnArray $columnHeaders
			WriteHTMLLine 0 0 " "		
		}

		Write-Verbose "$(Get-Date):    Network Info"
		WriteHTMLLine 1 0 "Network Information"
		WriteHTMLLine 0 0 ""
		
		[int] $cnt = 0
		$nics = @($xmlDoc.StoreFront.Hardware.Network.NIC)
		foreach ($nic in $nics)
		{
			++$cnt
			$columnHeaders = @("Name",($htmlsilver -bor $htmlbold),$nic.Name,$htmlWhite)
			$rowdata = @()
			$rowdata += @(,("Connection type",($htmlsilver -bor $htmlbold),$nic.ConnectionID,$htmlWhite))
			$rowdata += @(,("Availability",($htmlsilver -bor $htmlbold),$nic.Availability,$htmlWhite))
			$rowdata += @(,("Mac address",($htmlsilver -bor $htmlbold),$nic.PhyicalAddress,$htmlWhite))
			$rowdata += @(,("IP address",($htmlsilver -bor $htmlbold),$nic.IPAddress,$htmlWhite))
			$rowdata += @(,("Subnet mask",($htmlsilver -bor $htmlbold),$nic.SubnetMask,$htmlWhite))

			$DNSsuffixes = @($nic.DNSSearchSuffixes.DNSDomain)
			$strItems = ""
			foreach($item in $DNSsuffixes) {if($strItems -eq "") {$strItems += "$($item)"} else {$strItems += "<br>$($item)"} }			
			$rowdata += @(,("DNS Search Suffixes",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))
			$rowdata += @(,("WINS enabled",($htmlsilver -bor $htmlbold),$nic.WINSEnabled,$htmlWhite))

			$DNSServers = @($nic.DNSServers.DNSServer)
			$strItems = ""
			foreach($item in $DNSServers) {if($strItems -eq "") {$strItems += "$($item)"} else {$strItems += "<br>$($item)"} }			
			$rowdata += @(,("DNS Servers",($htmlsilver -bor $htmlbold),$strItems,$htmlWhite))
			$rowdata += @(,("NetBIOS",($htmlsilver -bor $htmlbold),$nic.NetBIOS,$htmlWhite))
			$rowdata += @(,("Enabled LMHosts",($htmlsilver -bor $htmlbold),$nic.EnabledLMHosts,$htmlWhite))
			
			FormatHTMLTable "NIC $($cnt)" "50%" -rowArray $rowdata -columnArray $columnHeaders
			WriteHTMLLine 0 0 " "		
		}
	}
	
	# do we have software info?
	if ($xmlDoc.StoreFront.Software -ne $Null) 
	{
		$Chapter++
		$appendix = "B"
		if ($xmlDoc.StoreFront.Hardware -eq $Null) { $appendix = "A" }
		Write-Host "$(Get-Date): Chapter $Chapter/$Chapters Appendix $($appendix): Software"
		WriteHTMLLine 1 0 "Appendix $($appendix): Software"
		WriteHTMLLine 0 0 ""

		Write-Host "$(Get-Date):    Installed Applications"

		$applications = @($xmlDoc.StoreFront.Software.InstalledApplications.Application)
		$columnHeaders = @("Application Name",($htmlsilver -bor $htmlbold),"Version",($htmlsilver -bor $htmlbold))
		$rowdata = @()

		foreach ($application in $applications)
		{
			$rowdata += @(,($application.Name,$htmlWhite,$application.Version,$htmlWhite))
		}
		FormatHTMLTable "Installed Applications" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "



		Write-Verbose "$(Get-Date):    Citrix Services"

		$services =  @($xmlDoc.StoreFront.Software.CitrixServices.Service)
		$columnHeaders = @("Service Name",($htmlsilver -bor $htmlbold),"State",($htmlsilver -bor $htmlbold),"Start Mode",($htmlsilver -bor $htmlbold))
		$rowdata = @()

		foreach ($service in $services)
		{
			$statusColor = $htmlWhite; if ($service.State -eq "Stopped") {$statusColor = $htmlRed}
			$rowdata += @(,($service.Name,$htmlWhite,$service.State,$statusColor,$service.StartMode,$htmlWhite))
		}
		FormatHTMLTable "Citrix Services" "50%" -rowArray $rowdata -columnArray $columnHeaders
		WriteHTMLLine 0 0 " "

	}			
}

Write-Verbose "$(Get-Date): Finishing up document"
#end of document processing

###Change the two lines below for your script
$AbstractTitle = "StoreFront Documentation"
$SubjectTitle = "StoreFront Documentation Report"
UpdateDocumentProperties $AbstractTitle $SubjectTitle

If($MSWORD -or $PDF)
{
    SaveandCloseDocumentandShutdownWord
}
ElseIf($Text)
{
    SaveandCloseTextDocument
}
ElseIf($HTML)
{
    SaveandCloseHTMLDocument
}

Write-Host "$(Get-Date): Script has completed"
Write-Host "$(Get-Date): "

If($PDF)
{
	If(Test-Path "$($Script:FileName2)")
	{
		Write-Verbose "$(Get-Date): $($Script:FileName2) is ready for use"
	}
	Else
	{
		Write-Warning "$(Get-Date): Unable to save the output file, $($Script:FileName2)"
		Write-Error "Unable to save the output file, $($Script:FileName2)"
	}
}
Else
{
	If(Test-Path "$($Script:FileName1)")
	{
		Write-Verbose "$(Get-Date): $($Script:FileName1) is ready for use"
	}
	Else
	{
		Write-Warning "$(Get-Date): Unable to save the output file, $($Script:FileName1)"
		Write-Error "Unable to save the output file, $($Script:FileName1)"
	}
}

Write-Verbose "$(Get-Date): "

#http://poshtips.com/measuring-elapsed-time-in-powershell/
Write-Host "$(Get-Date): Script started: $($Script:StartTime)"
Write-Host "$(Get-Date): Script ended: $(Get-Date)"
$runtime = $(Get-Date) - $Script:StartTime
$Str = [string]::format("{0} days, {1} hours, {2} minutes, {3}.{4} seconds", `
	$runtime.Days, `
	$runtime.Hours, `
	$runtime.Minutes, `
	$runtime.Seconds,
	$runtime.Milliseconds)
Write-Host "$(Get-Date): Elapsed time: $($Str)"
$runtime = $Null
$Str = $Null
$ErrorActionPreference = $SaveEAPreference

# SIG # Begin signature block
# MIIcXgYJKoZIhvcNAQcCoIIcTzCCHEsCAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUrYi2isUpqy+1+7b58m7ISZ1/
# vrSggheNMIIFFjCCA/6gAwIBAgIQDDQt7Y1XuhbY8RuUWoZC3jANBgkqhkiG9w0B
# AQsFADByMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYD
# VQQLExB3d3cuZGlnaWNlcnQuY29tMTEwLwYDVQQDEyhEaWdpQ2VydCBTSEEyIEFz
# c3VyZWQgSUQgQ29kZSBTaWduaW5nIENBMB4XDTE1MDcwMzAwMDAwMFoXDTE2MDcw
# NzEyMDAwMFowXTELMAkGA1UEBhMCVVMxETAPBgNVBAgTCE5ldyBZb3JrMREwDwYD
# VQQHEwhCcm9va2x5bjETMBEGA1UEChMKU2FtIEphY29iczETMBEGA1UEAxMKU2Ft
# IEphY29iczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOQ4wYU8jGsS
# RWKjY9nEagcepUTxVH5KYvzo9QZ+Zq2aBYxvwvq5A6l4ufm55r8yWinzzty23wsg
# /NYyLiQMpUICPNQmlNow2sJQTwZ2apHaN4EMnOyNSqE96ctmVP8UG+4OUV+47kH0
# xGc+CL8oW4UJPFXNQXDYMotwoMyIBx9idPeGJn7SbQj28fsa6xPCcnyYNT3/KjLU
# PIdSPvyDrunKNfbdh1UUVPqjevEx90Fwgk9rz8Oi7+v8piD+/k3/gPxhIq4okA4s
# Bk9vISAWGV8u89UufbH0p1fPhuoDvV7DW+SdbNiZPkECNL0NKLcC/LG4olnnkcjV
# a3NYgWm8PhECAwEAAaOCAbswggG3MB8GA1UdIwQYMBaAFFrEuXsqCqOl6nEDwGD5
# LfZldQ5YMB0GA1UdDgQWBBQWHubvgEwt1VoZUpyezIIll2vT4jAOBgNVHQ8BAf8E
# BAMCB4AwEwYDVR0lBAwwCgYIKwYBBQUHAwMwdwYDVR0fBHAwbjA1oDOgMYYvaHR0
# cDovL2NybDMuZGlnaWNlcnQuY29tL3NoYTItYXNzdXJlZC1jcy1nMS5jcmwwNaAz
# oDGGL2h0dHA6Ly9jcmw0LmRpZ2ljZXJ0LmNvbS9zaGEyLWFzc3VyZWQtY3MtZzEu
# Y3JsMEIGA1UdIAQ7MDkwNwYJYIZIAYb9bAMBMCowKAYIKwYBBQUHAgEWHGh0dHBz
# Oi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwgYQGCCsGAQUFBwEBBHgwdjAkBggrBgEF
# BQcwAYYYaHR0cDovL29jc3AuZGlnaWNlcnQuY29tME4GCCsGAQUFBzAChkJodHRw
# Oi8vY2FjZXJ0cy5kaWdpY2VydC5jb20vRGlnaUNlcnRTSEEyQXNzdXJlZElEQ29k
# ZVNpZ25pbmdDQS5jcnQwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQsFAAOCAQEA
# EvjF6gTkMvIxd2EmcRt/oG9wLL33kuXzIYNUPj0pQIub0yAKsDzJmHpoJdsSaTjW
# Taf7Y9ZLOdvPHJB4si2cAof3C3xFxBHD2IFMZy5dF53/VRWA82Q7SzIBEQbuhIYp
# EzaiLXOmJ7TbKxlmpvHDNVtFevDqgoHR9KTS+J6Ycy0yDkwju+W09OcosMuHH1SR
# kQvixNpVwn41e9tU2lD7oHVh3ct6Oiz6a/J563gDFcYmvvmrW4vJTEBZjzLvkUaB
# U8AbKxy5WHJO12nV3O2SHaLntIn2RY+XH/NIHGnoZzS7O6ZzogBEwrYpKe9vubSp
# +f/CpbZgSrBnDrLNeVUTyDCCBTAwggQYoAMCAQICEAQJGBtf1btmdVNDtW+VUAgw
# DQYJKoZIhvcNAQELBQAwZTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0
# IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEkMCIGA1UEAxMbRGlnaUNl
# cnQgQXNzdXJlZCBJRCBSb290IENBMB4XDTEzMTAyMjEyMDAwMFoXDTI4MTAyMjEy
# MDAwMFowcjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcG
# A1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTExMC8GA1UEAxMoRGlnaUNlcnQgU0hBMiBB
# c3N1cmVkIElEIENvZGUgU2lnbmluZyBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEP
# ADCCAQoCggEBAPjTsxx/DhGvZ3cH0wsxSRnP0PtFmbE620T1f+Wondsy13Hqdp0F
# LreP+pJDwKX5idQ3Gde2qvCchqXYJawOeSg6funRZ9PG+yknx9N7I5TkkSOWkHeC
# +aGEI2YSVDNQdLEoJrskacLCUvIUZ4qJRdQtoaPpiCwgla4cSocI3wz14k1gGL6q
# xLKucDFmM3E+rHCiq85/6XzLkqHlOzEcz+ryCuRXu0q16XTmK/5sy350OTYNkO/k
# tU6kqepqCquE86xnTrXE94zRICUj6whkPlKWwfIPEvTFjg/BougsUfdzvL2FsWKD
# c0GCB+Q4i2pzINAPZHM8np+mM6n9Gd8lk9ECAwEAAaOCAc0wggHJMBIGA1UdEwEB
# /wQIMAYBAf8CAQAwDgYDVR0PAQH/BAQDAgGGMBMGA1UdJQQMMAoGCCsGAQUFBwMD
# MHkGCCsGAQUFBwEBBG0wazAkBggrBgEFBQcwAYYYaHR0cDovL29jc3AuZGlnaWNl
# cnQuY29tMEMGCCsGAQUFBzAChjdodHRwOi8vY2FjZXJ0cy5kaWdpY2VydC5jb20v
# RGlnaUNlcnRBc3N1cmVkSURSb290Q0EuY3J0MIGBBgNVHR8EejB4MDqgOKA2hjRo
# dHRwOi8vY3JsNC5kaWdpY2VydC5jb20vRGlnaUNlcnRBc3N1cmVkSURSb290Q0Eu
# Y3JsMDqgOKA2hjRodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRBc3N1
# cmVkSURSb290Q0EuY3JsME8GA1UdIARIMEYwOAYKYIZIAYb9bAACBDAqMCgGCCsG
# AQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMAoGCGCGSAGG/WwD
# MB0GA1UdDgQWBBRaxLl7KgqjpepxA8Bg+S32ZXUOWDAfBgNVHSMEGDAWgBRF66Kv
# 9JLLgjEtUYunpyGd823IDzANBgkqhkiG9w0BAQsFAAOCAQEAPuwNWiSz8yLRFcgs
# fCUpdqgdXRwtOhrE7zBh134LYP3DPQ/Er4v97yrfIFU3sOH20ZJ1D1G0bqWOWuJe
# JIFOEKTuP3GOYw4TS63XX0R58zYUBor3nEZOXP+QsRsHDpEV+7qvtVHCjSSuJMbH
# JyqhKSgaOnEoAjwukaPAJRHinBRHoXpoaK+bp1wgXNlxsQyPu6j4xRJon89Ay0BE
# pRPw5mQMJQhCMrI2iiQC/i9yfhzXSUWW6Fkd6fp0ZGuy62ZD2rOwjNXpDd32ASDO
# mTFjPQgaGLOBm0/GkxAG/AeB+ova+YJJ92JuoVP6EpQYhS6SkepobEQysmah5xik
# mmRR7zCCBmowggVSoAMCAQICEAMBmgI6/1ixa9bV6uYX8GYwDQYJKoZIhvcNAQEF
# BQAwYjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UE
# CxMQd3d3LmRpZ2ljZXJ0LmNvbTEhMB8GA1UEAxMYRGlnaUNlcnQgQXNzdXJlZCBJ
# RCBDQS0xMB4XDTE0MTAyMjAwMDAwMFoXDTI0MTAyMjAwMDAwMFowRzELMAkGA1UE
# BhMCVVMxETAPBgNVBAoTCERpZ2lDZXJ0MSUwIwYDVQQDExxEaWdpQ2VydCBUaW1l
# c3RhbXAgUmVzcG9uZGVyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
# o2Rd/Hyz4II14OD2xirmSXU7zG7gU6mfH2RZ5nxrf2uMnVX4kuOe1VpjWwJJUNmD
# zm9m7t3LhelfpfnUh3SIRDsZyeX1kZ/GFDmsJOqoSyyRicxeKPRktlC39RKzc5YK
# Z6O+YZ+u8/0SeHUOplsU/UUjjoZEVX0YhgWMVYd5SEb3yg6Np95OX+Koti1ZAmGI
# YXIYaLm4fO7m5zQvMXeBMB+7NgGN7yfj95rwTDFkjePr+hmHqH7P7IwMNlt6wXq4
# eMfJBi5GEMiN6ARg27xzdPpO2P6qQPGyznBGg+naQKFZOtkVCVeZVjCT88lhzNAI
# zGvsYkKRrALA76TwiRGPdwIDAQABo4IDNTCCAzEwDgYDVR0PAQH/BAQDAgeAMAwG
# A1UdEwEB/wQCMAAwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwgwggG/BgNVHSAEggG2
# MIIBsjCCAaEGCWCGSAGG/WwHATCCAZIwKAYIKwYBBQUHAgEWHGh0dHBzOi8vd3d3
# LmRpZ2ljZXJ0LmNvbS9DUFMwggFkBggrBgEFBQcCAjCCAVYeggFSAEEAbgB5ACAA
# dQBzAGUAIABvAGYAIAB0AGgAaQBzACAAQwBlAHIAdABpAGYAaQBjAGEAdABlACAA
# YwBvAG4AcwB0AGkAdAB1AHQAZQBzACAAYQBjAGMAZQBwAHQAYQBuAGMAZQAgAG8A
# ZgAgAHQAaABlACAARABpAGcAaQBDAGUAcgB0ACAAQwBQAC8AQwBQAFMAIABhAG4A
# ZAAgAHQAaABlACAAUgBlAGwAeQBpAG4AZwAgAFAAYQByAHQAeQAgAEEAZwByAGUA
# ZQBtAGUAbgB0ACAAdwBoAGkAYwBoACAAbABpAG0AaQB0ACAAbABpAGEAYgBpAGwA
# aQB0AHkAIABhAG4AZAAgAGEAcgBlACAAaQBuAGMAbwByAHAAbwByAGEAdABlAGQA
# IABoAGUAcgBlAGkAbgAgAGIAeQAgAHIAZQBmAGUAcgBlAG4AYwBlAC4wCwYJYIZI
# AYb9bAMVMB8GA1UdIwQYMBaAFBUAEisTmLKZB+0e36K+Vw0rZwLNMB0GA1UdDgQW
# BBRhWk0ktkkynUoqeRqDS/QeicHKfTB9BgNVHR8EdjB0MDigNqA0hjJodHRwOi8v
# Y3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRBc3N1cmVkSURDQS0xLmNybDA4oDag
# NIYyaHR0cDovL2NybDQuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEQ0Et
# MS5jcmwwdwYIKwYBBQUHAQEEazBpMCQGCCsGAQUFBzABhhhodHRwOi8vb2NzcC5k
# aWdpY2VydC5jb20wQQYIKwYBBQUHMAKGNWh0dHA6Ly9jYWNlcnRzLmRpZ2ljZXJ0
# LmNvbS9EaWdpQ2VydEFzc3VyZWRJRENBLTEuY3J0MA0GCSqGSIb3DQEBBQUAA4IB
# AQCdJX4bM02yJoFcm4bOIyAPgIfliP//sdRqLDHtOhcZcRfNqRu8WhY5AJ3jbITk
# WkD73gYBjDf6m7GdJH7+IKRXrVu3mrBgJuppVyFdNC8fcbCDlBkFazWQEKB7l8f2
# P+fiEUGmvWLZ8Cc9OB0obzpSCfDscGLTYkuw4HOmksDTjjHYL+NtFxMG7uQDthSr
# 849Dp3GdId0UyhVdkkHa+Q+B0Zl0DSbEDn8btfWg8cZ3BigV6diT5VUW8LsKqxzb
# XEgnZsijiwoc5ZXarsQuWaBh3drzbaJh6YoLbewSGL33VVRAA5Ira8JRwgpIr7DU
# buD0FAo6G+OPPcqvao173NhEMIIGzTCCBbWgAwIBAgIQBv35A5YDreoACus/J7u6
# GzANBgkqhkiG9w0BAQUFADBlMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNl
# cnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSQwIgYDVQQDExtEaWdp
# Q2VydCBBc3N1cmVkIElEIFJvb3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMjExMTEw
# MDAwMDAwWjBiMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkw
# FwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSEwHwYDVQQDExhEaWdpQ2VydCBBc3N1
# cmVkIElEIENBLTEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDogi2Z
# +crCQpWlgHNAcNKeVlRcqcTSQQaPyTP8TUWRXIGf7Syc+BZZ3561JBXCmLm0d0nc
# icQK2q/LXmvtrbBxMevPOkAMRk2T7It6NggDqww0/hhJgv7HxzFIgHweog+SDlDJ
# xofrNj/YMMP/pvf7os1vcyP+rFYFkPAyIRaJxnCI+QWXfaPHQ90C6Ds97bFBo+0/
# vtuVSMTuHrPyvAwrmdDGXRJCgeGDboJzPyZLFJCuWWYKxI2+0s4Grq2Eb0iEm09A
# ufFM8q+Y+/bOQF1c9qjxL6/siSLyaxhlscFzrdfx2M8eCnRcQrhofrfVdwonVnwP
# YqQ/MhRglf0HBKIJAgMBAAGjggN6MIIDdjAOBgNVHQ8BAf8EBAMCAYYwOwYDVR0l
# BDQwMgYIKwYBBQUHAwEGCCsGAQUFBwMCBggrBgEFBQcDAwYIKwYBBQUHAwQGCCsG
# AQUFBwMIMIIB0gYDVR0gBIIByTCCAcUwggG0BgpghkgBhv1sAAEEMIIBpDA6Bggr
# BgEFBQcCARYuaHR0cDovL3d3dy5kaWdpY2VydC5jb20vc3NsLWNwcy1yZXBvc2l0
# b3J5Lmh0bTCCAWQGCCsGAQUFBwICMIIBVh6CAVIAQQBuAHkAIAB1AHMAZQAgAG8A
# ZgAgAHQAaABpAHMAIABDAGUAcgB0AGkAZgBpAGMAYQB0AGUAIABjAG8AbgBzAHQA
# aQB0AHUAdABlAHMAIABhAGMAYwBlAHAAdABhAG4AYwBlACAAbwBmACAAdABoAGUA
# IABEAGkAZwBpAEMAZQByAHQAIABDAFAALwBDAFAAUwAgAGEAbgBkACAAdABoAGUA
# IABSAGUAbAB5AGkAbgBnACAAUABhAHIAdAB5ACAAQQBnAHIAZQBlAG0AZQBuAHQA
# IAB3AGgAaQBjAGgAIABsAGkAbQBpAHQAIABsAGkAYQBiAGkAbABpAHQAeQAgAGEA
# bgBkACAAYQByAGUAIABpAG4AYwBvAHIAcABvAHIAYQB0AGUAZAAgAGgAZQByAGUA
# aQBuACAAYgB5ACAAcgBlAGYAZQByAGUAbgBjAGUALjALBglghkgBhv1sAxUwEgYD
# VR0TAQH/BAgwBgEB/wIBADB5BggrBgEFBQcBAQRtMGswJAYIKwYBBQUHMAGGGGh0
# dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBDBggrBgEFBQcwAoY3aHR0cDovL2NhY2Vy
# dHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNydDCBgQYD
# VR0fBHoweDA6oDigNoY0aHR0cDovL2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0
# QXNzdXJlZElEUm9vdENBLmNybDA6oDigNoY0aHR0cDovL2NybDQuZGlnaWNlcnQu
# Y29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNybDAdBgNVHQ4EFgQUFQASKxOY
# spkH7R7for5XDStnAs0wHwYDVR0jBBgwFoAUReuir/SSy4IxLVGLp6chnfNtyA8w
# DQYJKoZIhvcNAQEFBQADggEBAEZQPsm3KCSnOB22WymvUs9S6TFHq1Zce9UNC0Gz
# 7+x1H3Q48rJcYaKclcNQ5IK5I9G6OoZyrTh4rHVdFxc0ckeFlFbR67s2hHfMJKXz
# BBlVqefj56tizfuLLZDCwNK1lL1eT7EF0g49GqkUW6aGMWKoqDPkmzmnxPXOHXh2
# lCVz5Cqrz5x2S+1fwksW5EtwTACJHvzFebxMElf+X+EevAJdqP77BzhPDcZdkbkP
# Z0XN1oPt55INjbFpjE/7WeAjD9KqrgB87pxCDs+R1ye3Fu4Pw718CqDuLAhVhSK4
# 6xgaTfwqIa1JMYNHlXdx3LEbS0scEJx3FMGdTy9alQgpECYxggQ7MIIENwIBATCB
# hjByMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQL
# ExB3d3cuZGlnaWNlcnQuY29tMTEwLwYDVQQDEyhEaWdpQ2VydCBTSEEyIEFzc3Vy
# ZWQgSUQgQ29kZSBTaWduaW5nIENBAhAMNC3tjVe6FtjxG5RahkLeMAkGBSsOAwIa
# BQCgeDAYBgorBgEEAYI3AgEMMQowCKACgAChAoAAMBkGCSqGSIb3DQEJAzEMBgor
# BgEEAYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3
# DQEJBDEWBBTwYMmsVpXc9NW16LR1VaG3KRoV4zANBgkqhkiG9w0BAQEFAASCAQDf
# 1nMc96xsGgRsW7pj2ZuJQDPoTP4YwwABBcp7gGAFwGhdfC8rtr+ExIDy3DpgZwsP
# cSLhPV49Y2tpf00ee1E0DByWfrUGLWyzP97mH49R1aFv2xz4VJqf8WYl/4+a9QzF
# lb4lYfmUBaFBM/eYMmm0Y9pj7TdGBFCtMK4I96Eh0D/GOvAdXuJ14f6hGSLxeWif
# /wuq9nA3ckko+c2YH9Pbycd4h1x1zDvxVHs5g8NcIqhb1F/iNW3k1lIbaZrKA0Jg
# EBuw0JKI20M/b7JeZnmgqsU+f2iJl/3HiDm6I9L/HxICuZUrmHKguMqOSSENSj8e
# YZvorkEasjkqOIyWq5b0oYICDzCCAgsGCSqGSIb3DQEJBjGCAfwwggH4AgEBMHYw
# YjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQ
# d3d3LmRpZ2ljZXJ0LmNvbTEhMB8GA1UEAxMYRGlnaUNlcnQgQXNzdXJlZCBJRCBD
# QS0xAhADAZoCOv9YsWvW1ermF/BmMAkGBSsOAwIaBQCgXTAYBgkqhkiG9w0BCQMx
# CwYJKoZIhvcNAQcBMBwGCSqGSIb3DQEJBTEPFw0xNTA3MjIxNTI2MDJaMCMGCSqG
# SIb3DQEJBDEWBBRBXLVzKGLsbrmv9uqXOhwIS3EDuTANBgkqhkiG9w0BAQEFAASC
# AQBmX7AR0g03ghVu1bpAZlgn8QuAz80VChHMxBoyILdjsjqUuQocnjyaNlsouthv
# 3wvCjL8Egiw6o278XVPdJxEJTo0ZKbfSGxfoow3qe3TzcxtQQbxwsWlJJlOX4FWJ
# 5vZovwxtisgcu1AZp8wRYaw8ViRbLSaysnLoAX7CVUmRW1mD4msm7AdkA0X6F44M
# nzFaks94atqo/HOEuC4Y2RJaimfZXPaAJsCoO26Cju7VDMlo/7b8TYKlJ0F3arXj
# 1mXzF6llzK5D856zx6yojXEEU0FWaa/7bMt0fymcihCohJ5yqVw6cqitrTV9xDI0
# HKjBFQUcA+nvIPWoMCLybaJR
# SIG # End signature block
